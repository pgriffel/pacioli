<h1>Pacioli Specification</h1>

<p>Specification of the functions in Pacioli v0.0.0</p>

<hr>

<h2>Contents</h2>

<ul>
<li><a href="#general">General</a> </li>
<li><a href="#boolean">Boolean</a> </li>
<li><a href="#matrix">Matrix</a> 
<ul>
<li><a href="#shape">Shape</a> </li>
<li><a href="#numerical">Numerical</a> </li>
<li><a href="#closures">Closures</a> </li>
<li><a href="#trigonometry">Trigonometry</a> </li>
</ul></li>
<li><a href="#list">List</a> </li>
</ul>

<h2>General <a id="general"/></h2>

<p><code>
<a href="#identity">identity</a> :: for_type a: (a) -> a <br>
<a href="#apply">apply</a> :: for_type a,b: (a -> b, a) -> b <br>
<a href="#tuple">tuple</a> :: for_type a: a -> a <br>
<a href="#print">print</a> :: for_type a: (a) -> a <br>
</code></p>

<h4>Function identity <a id="identity"/></h4>

<p>The identity function</p>

<pre><code>identity :: for_type a: (a) -&gt; a
</code></pre>

<p>Returns the given argument. Satisfies</p>

<pre><code>identity(x) = x
</code></pre>

<h4>Function apply <a id="apply"/></h4>

<p>Applies a function to arguments</p>

<pre><code>apply :: for_type a,b: (a -&gt; b, a) -&gt; b
</code></pre>

<p>Satisfies <code>f(x, y, z) = apply(f, tuple(x, y, z))</code>.</p>

<h4>Function tuple <a id="tuple"/></h4>

<p>Creates a tuple</p>

<pre><code>tuple :: for_type a: a -&gt; a
</code></pre>

<p>Returns the arguments tuple. Satisfies <code>tuple x = x</code>. See function <code>apply</code>.</p>

<h4>Function print <a id="print"/></h4>

<p>Printed value</p>

<pre><code>print :: for_type a: (a) -&gt; a
</code></pre>

<p>Prints the given argument and returns it.</p>

<h2>Boolean <a id="boolean"/></h2>

<p><code>
<a href="#not">not</a> :: (Boole()) -> Boole() <br>
<a href="#equal">equal</a> :: for_type a: (a, a) -> Boole() <br>
<a href="#index_less">index_less</a> :: for_index P: (P, P) -> Boole() <br>
<a href="#less">less</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> Boole() <br>
<a href="#less_eq">less_eq</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> Boole() <br>
</code></p>

<h4>Function not <a id="not"/></h4>

<p>Logical not</p>

<pre><code>not :: (Boole()) -&gt; Boole()
</code></pre>

<p>The logical negation of the given boolean value.</p>

<h4>Function equal <a id="equal"/></h4>

<p>Equality</p>

<pre><code>equal :: for_type a: (a, a) -&gt; Boole()
</code></pre>

<p>Are two values equal?</p>

<h4>Function index_less <a id="index_less"/></h4>

<p>Ordering of indices</p>

<pre><code>index_less :: for_index P: (P, P) -&gt; Boole()
</code></pre>

<p>Is the first index less than the second one.</p>

<h4>Function less <a id="less"/></h4>

<p>Compares two matrices</p>

<pre><code>less :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -&gt; Boole()
</code></pre>

<p>True iff each element in the first argument is less than each corresponding element in the second argument</p>

<h4>Function less_eq <a id="less_eq"/></h4>

<p>Compares two matrices</p>

<pre><code>less_eq :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -&gt; Boole()
</code></pre>

<p>True iff each element in the first argument is less than or equal to each corresponding element in the second argument</p>

<h2>Matrix <a id="matrix"/></h2>

<p><code>
</code></p>

<h3>Shape <a id="shape"/></h3>

<p><code>
<a href="#make_matrix">make_matrix</a> :: for_index P,Q: for_unit a: (List(Tuple(P, Q, a))) -> a*P! per Q! <br>
<a href="#row_domain">row_domain</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> List(P) <br>
<a href="#column_domain">column_domain</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> List(Q) <br>
<a href="#get">get</a> :: for_index P,Q: for_unit a: (a*P! per Q!, P, Q) -> a <br>
<a href="#get_num">get_num</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c, D, E) -> 1 <br>
<a href="#row">row</a> :: for_index P,Q: for_unit a,v: (a*P! per Q!v, P) -> a per Q!v <br>
<a href="#column">column</a> :: for_index P,Q: for_unit a,v: (a*P!v per Q!, Q) -> a*P!v <br>
<a href="#rows">rows</a> :: for_index P,Q: for_unit a,v: (a*P! per Q!v) -> List(a per Q!v) <br>
<a href="#columns">columns</a> :: for_index P,Q: for_unit a,u: (a*P!u per Q!) -> List(a*P!u) <br>
<a href="#magnitude">magnitude</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> P! per Q! <br>
<a href="#unit">unit</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a*P!u per Q!v <br>
<a href="#unit_factor">unit_factor</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a <br>
<a href="#row_units">row_units</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> P!u <br>
<a href="#column_units">column_units</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Q!v <br>
<a href="#map_matrix">map_matrix</a> :: for_index P,Q: for_unit a,b: ((a) -> b, a*P! per Q!) -> b*P! per Q! <br>
<a href="#diagonal">diagonal</a> :: for_index P: for_unit a,u: (a*P!u) -> a*P!u per P!u <br>
<a href="#diagonal2">diagonal2</a> :: for_index P: for_unit a,u: (a*P!u) -> a*P!u per P! <br>
<a href="#left_identity">left_identity</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> P!u per P!u <br>
<a href="#right_identity">right_identity</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Q!v per Q!v <br>
<a href="#delta">delta</a> :: for_index P: (P) -> P! <br>
<a href="#basis">basis</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -> List(D!) <br>
<a href="#support">support</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -> D! per E! <br>
<a href="#positive_support">positive_support</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -> D! per E! <br>
<a href="#negative_support">negative_support</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -> D! per E! <br>
<a href="#positives">positives</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -> a*D!b per E!c <br>
<a href="#negatives">negatives</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -> a*D!b per E!c <br>
</code></p>

<h4>Function make_matrix <a id="make_matrix"/></h4>

<p>Creates a matrix from a list of key key value triples</p>

<pre><code>make_matrix :: for_index P,Q: for_unit a: (List(Tuple(P, Q, a))) -&gt; a*P! per Q!
</code></pre>

<p>Each triple must contain a row key, a column key and a value.</p>

<h4>Function row_domain <a id="row_domain"/></h4>

<p>The list of row indices of a matrix</p>

<pre><code>row_domain :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; List(P)
</code></pre>

<h4>Function column_domain <a id="column_domain"/></h4>

<p>The list of column indices of a matrix</p>

<pre><code>column_domain :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; List(Q)
</code></pre>

<h4>Function get <a id="get"/></h4>

<p>Gets the matrix value for a row index and column index</p>

<pre><code>get :: for_index P,Q: for_unit a: (a*P! per Q!, P, Q) -&gt; a
</code></pre>

<p>The result includes the unit of measurement. The matrix must have homogeneous units. See also function <a href="#get_num"><code>get_num</code></a>.</p>

<h4>Function get_num <a id="get_num"/></h4>

<p>Gets the magnitude for a row index and column index</p>

<pre><code>get_num :: for_index D,E: for_unit a,b,c: (a*D!b per E!c, D, E) -&gt; 1
</code></pre>

<p>The result does not include the unit of measurement. See also function <a href="#get"><code>get</code></a>.</p>

<h4>Function row <a id="row"/></h4>

<p>The matrix row for the given index</p>

<pre><code>row :: for_index P,Q: for_unit a,v: (a*P! per Q!v, P) -&gt; a per Q!v
</code></pre>

<p>The matrix type must be homogeneous in the row dimension.</p>

<h4>Function column <a id="column"/></h4>

<p>The matrix column for the given index</p>

<pre><code>column :: for_index P,Q: for_unit a,v: (a*P!v per Q!, Q) -&gt; a*P!v
</code></pre>

<p>The matrix type must be homogeneous in the column dimension.</p>

<h4>Function rows <a id="rows"/></h4>

<p>The list of all matrix rows</p>

<pre><code>rows :: for_index P,Q: for_unit a,v: (a*P! per Q!v) -&gt; List(a per Q!v)
</code></pre>

<p>The matrix type must be homogeneous in the row dimension.</p>

<h4>Function columns <a id="columns"/></h4>

<p>The list of all matrix columns</p>

<pre><code>columns :: for_index P,Q: for_unit a,u: (a*P!u per Q!) -&gt; List(a*P!u)
</code></pre>

<p>The matrix type must be homogeneous in the column dimension.</p>

<h4>Function magnitude <a id="magnitude"/></h4>

<p>The magnitude matrix</p>

<pre><code>magnitude :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; P! per Q!
</code></pre>

<p>Dimensionless copy matrix of the given matrix. Satisfies <code>x = magnitude(x) * unit(x)</code>.</p>

<h4>Function unit <a id="unit"/></h4>

<p>The unit of a matrix</p>

<pre><code>unit :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; a*P!u per Q!v
</code></pre>

<p>Matrix of the same unit as the given matrix with value 1 for every element. See also function <a href="#magnitude"><code>magnitude</code></a>. Satisfies <code>unit(x) = unit_factor(x) . row_units(x) per column_units(x)</code>.</p>

<h4>Function unit_factor <a id="unit_factor"/></h4>

<p>The scalar unit factor of a matrix</p>

<pre><code>unit_factor :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; a
</code></pre>

<p>See also function <a href="#unit"><code>unit</code></a>.</p>

<h4>Function row_units <a id="row_units"/></h4>

<p>The row units of a matrix</p>

<pre><code>row_units :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; P!u
</code></pre>

<p>A unit vector with the row units of the matrix. See also function <a href="#unit"><code>unit</code></a>.</p>

<h4>Function column_units <a id="column_units"/></h4>

<p>The column units of a matrix</p>

<pre><code>column_units :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; Q!v
</code></pre>

<p>A unit vector with the row units of the matrix. See also function <a href="#unit"><code>unit</code></a>.</p>

<h4>Function map_matrix <a id="map_matrix"/></h4>

<p>Applies a function to the elements of a matrix</p>

<pre><code>map_matrix :: for_index P,Q: for_unit a,b: ((a) -&gt; b, a*P! per Q!) -&gt; b*P! per Q!
</code></pre>

<p>The matrix must have homogeneous units of measurement.</p>

<h4>Function diagonal <a id="diagonal"/></h4>

<p>Creates a diagonal matrix from a vector</p>

<pre><code>diagonal :: for_index P: for_unit a,u: (a*P!u) -&gt; a*P!u per P!u
</code></pre>

<p>See also function <a href="#diagonal2"><code>diagonal2</code></a>.</p>

<h4>Function diagonal2 <a id="diagonal2"/></h4>

<p>Creates a dimensioned diagonal matrix from a vector</p>

<pre><code>diagonal2 :: for_index P: for_unit a,u: (a*P!u) -&gt; a*P!u per P!
</code></pre>

<p>See also function <a href="#diagonal"><code>diagonal</code></a>.</p>

<h4>Function left_identity <a id="left_identity"/></h4>

<p>Identity matrix from a matrix row dimension</p>

<pre><code>left_identity :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; P!u per P!u
</code></pre>

<p>The identity matrix for matrix multiplication from the left.</p>

<h4>Function right_identity <a id="right_identity"/></h4>

<p>Identity matrix from a matrix column dimension</p>

<pre><code>right_identity :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; Q!v per Q!v
</code></pre>

<p>The identity matrix for matrix multiplication from the right.</p>

<h4>Function delta <a id="delta"/></h4>

<p>Kronecker delta</p>

<pre><code>delta :: for_index P: (P) -&gt; P!
</code></pre>

<p>Vector with a one for the given index and zero everywhere else.</p>

<h4>Function basis <a id="basis"/></h4>

<p>Basis vectors for the row dimension of the matrix</p>

<pre><code>basis :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -&gt; List(D!)
</code></pre>

<p>This is a list of the Kronecker delta of the row space, not a basis that spans the column space. It does not depend on the values in the matrix. See also function <a href="#delta"><code>delta</code></a>.</p>

<h4>Function support <a id="support"/></h4>

<p>Support of a matrix</p>

<pre><code>support :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -&gt; D! per E!
</code></pre>

<p>Matrix with one for every non zero value in the given matrix, and zero everywhere else.</p>

<h4>Function positive_support <a id="positive_support"/></h4>

<p>Positive support of a matrix</p>

<pre><code>positive_support :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -&gt; D! per E!
</code></pre>

<p>Matrix with one for every positive value in the given matrix, and zero everywhere else.</p>

<h4>Function negative_support <a id="negative_support"/></h4>

<p>Negative support of a matrix</p>

<pre><code>negative_support :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -&gt; D! per E!
</code></pre>

<p>Matrix with one for every negative value in the given matrix, and zero everywhere else.</p>

<h4>Function positives <a id="positives"/></h4>

<p>The positive values of a matrix</p>

<pre><code>positives :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -&gt; a*D!b per E!c
</code></pre>

<p>Copy of the given matrix with all negative values set to zero.</p>

<h4>Function negatives <a id="negatives"/></h4>

<p>The negatives values of a matrix</p>

<pre><code>negatives :: for_index D,E: for_unit a,b,c: (a*D!b per E!c) -&gt; a*D!b per E!c
</code></pre>

<p>Copy of the given matrix with all positives values set to zero.</p>

<h3>Numerical <a id="numerical"/></h3>

<p><code>
<a href="#negative">negative</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a*P!u per Q!v <br>
<a href="#transpose">transpose</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a/Q!v per 1/P!u <br>
<a href="#reciprocal">reciprocal</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> 1/P!u per a/Q!v <br>
<a href="#dim_inv">dim_inv</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Q!v per a*P!u <br>
<a href="#power">power</a> :: for_index P: for_unit u: (P!u per P!u, 1) -> P!u per P!u <br>
<a href="#expt">expt</a> :: for_index P,Q: (P! per Q!, 1) -> P! per Q! <br>
<a href="#exp">exp</a> :: for_index P,Q: (P! per Q!) -> P! per Q! <br>
<a href="#dim_div">dim_div</a> :: for_index D,E,H: for_unit a,b,c,f,g: (a*D!b per E!c, f*H!g per E!c) -> a*D!b per f*H!g <br>
<a href="#scale">scale</a> :: for_index P,Q: for_unit a,b,u,v: (a, b*P!u per Q!v) -> a*b*P!u per Q!v <br>
<a href="#scale_down">scale_down</a> :: for_index P,Q: for_unit a,b,u,v: (a*P!u per Q!v, b) -> a*P!u per b*Q!v <br>
<a href="#multiply">multiply</a> :: for_index P,Q: for_unit a,b,u,w,v,z: (a*P!u per Q!v, b*P!w per Q!z) -> a*b*P!u*P!w per Q!v*Q!z <br>
<a href="#divide">divide</a> :: for_index P,Q: for_unit a,b,u,v,x,y: (a*P!u per Q!v, b*P!x per Q!y) -> a*P!u/P!x per b/Q!v/Q!y <br>
<a href="#dot">dot</a> :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*Q!v per R!w) -> a*b*P!u per R!w <br>
<a href="#sum">sum</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> a*P!u per Q!v <br>
<a href="#minus">minus</a> :: for_index D,E: for_unit a,b,c: (a*D!b per E!c, a*D!b per E!c) -> a*D!b per E!c <br>
<a href="#inner">inner</a> :: for_index P: for_unit a,b,u: (a*P!u, b/P!u) -> a*b <br>
<a href="#outer">outer</a> :: for_index P,Q: for_unit a,b,u,v: (a*P!u, b*Q!v) -> a*b*P!u per 1/Q!v <br>
<a href="#total">total</a> :: for_index P,Q: for_unit a: (a*P! per Q!) -> a <br>
<a href="#sqrt">sqrt</a> :: for_index P,Q: for_unit a,u,v: (a^2*P!u^2 per Q!v^2) -> a*P!u per Q!v <br>
<a href="#ln">ln</a> :: for_index P,Q: (P! per Q!) -> P! per Q! <br>
<a href="#log">log</a> :: for_index P,Q: (P! per Q!, 1) -> P! per Q! <br>
<a href="#abs">abs</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a*P!u per Q!v <br>
<a href="#mod">mod</a> :: for_index P,Q: for_unit a,b,u,v,x,y: (a*P!u per Q!v, b*P!x per Q!y) -> a*P!u per Q!v <br>
<a href="#min">min</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> a*P!u per Q!v <br>
<a href="#max">max</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> a*P!u per Q!v <br>
<a href="#gcd">gcd</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> P! per Q! <br>
</code></p>

<h4>Function negative <a id="negative"/></h4>

<p>Negation of a matrix</p>

<pre><code>negative :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; a*P!u per Q!v
</code></pre>

<p>Switches the sign of each matrix element. Corresponds with the <code>-</code> operator.</p>

<h4>Function transpose <a id="transpose"/></h4>

<p>Matrix transpose</p>

<pre><code>transpose :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; a/Q!v per 1/P!u
</code></pre>

<p>Corresponds with the <code>^T</code> operator.</p>

<h4>Function reciprocal <a id="reciprocal"/></h4>

<p>Matrix reciprocal</p>

<pre><code>reciprocal :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; 1/P!u per a/Q!v
</code></pre>

<p>Element-wise reciprocal of the given matrix. The reciprocal of zero is zero. Corresponds with the <code>^R</code> operator.</p>

<h4>Function dim_inv <a id="dim_inv"/></h4>

<p>The dimensional inverse of a matrix</p>

<pre><code>dim_inv :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; Q!v per a*P!u
</code></pre>

<p>The dimensional inverse of the given matrix. It combines a transpose and reciprocal. Corresponds with the <code>^D</code> operator.</p>

<h4>Function power <a id="power"/></h4>

<p>Power of a matrix</p>

<pre><code>power :: for_index P: for_unit u: (P!u per P!u, 1) -&gt; P!u per P!u
</code></pre>

<p>Exponent with dot/matrix multiplication as base operator. Corresponds with the <code>.^</code> operator.</p>

<h4>Function expt <a id="expt"/></h4>

<p>Element-wise exponent</p>

<pre><code>expt :: for_index P,Q: (P! per Q!, 1) -&gt; P! per Q!
</code></pre>

<p>Exponent with element-wise multiplication as base operator. Corresponds with the <code>^</code> operator.</p>

<h4>Function exp <a id="exp"/></h4>

<p>Element-wise natural exponent</p>

<pre><code>exp :: for_index P,Q: (P! per Q!) -&gt; P! per Q!
</code></pre>

<p>Natural exponent with element-wise multiplication as base operator.</p>

<h4>Function dim_div <a id="dim_div"/></h4>

<p>Dimensional division</p>

<pre><code>dim_div :: for_index D,E,H: for_unit a,b,c,f,g: (a*D!b per E!c, f*H!g per E!c) -&gt; a*D!b per f*H!g
</code></pre>

<p>Corresponds with the <code>per</code> operator.</p>

<h4>Function scale <a id="scale"/></h4>

<p>Matrix scaling</p>

<pre><code>scale :: for_index P,Q: for_unit a,b,u,v: (a, b*P!u per Q!v) -&gt; a*b*P!u per Q!v
</code></pre>

<p>Multiplies each matrix element by the given scalar. Corresponds with the <code>.</code> operator.</p>

<h4>Function scale_down <a id="scale_down"/></h4>

<p>Matrix reciprocal scaling</p>

<pre><code>scale_down :: for_index P,Q: for_unit a,b,u,v: (a*P!u per Q!v, b) -&gt; a*P!u per b*Q!v
</code></pre>

<p>Divides each matrix element by the given scalar. Corresponds with the <code>/.</code> operator.</p>

<h4>Function multiply <a id="multiply"/></h4>

<p>Element-wise multiplication</p>

<pre><code>multiply :: for_index P,Q: for_unit a,b,u,w,v,z: (a*P!u per Q!v, b*P!w per Q!z) -&gt; a*b*P!u*P!w per Q!v*Q!z
</code></pre>

<p>Corresponds with the <code>*</code> operator.</p>

<h4>Function divide <a id="divide"/></h4>

<p>Element-wise division</p>

<pre><code>divide :: for_index P,Q: for_unit a,b,u,v,x,y: (a*P!u per Q!v, b*P!x per Q!y) -&gt; a*P!u/P!x per b/Q!v/Q!y
</code></pre>

<p>Corresponds with the <code>/</code> operator.</p>

<h4>Function dot <a id="dot"/></h4>

<p>Dot product</p>

<pre><code>dot :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*Q!v per R!w) -&gt; a*b*P!u per R!w
</code></pre>

<p>The dot/matrix product. Corresponds with the <code>.*</code> operator.</p>

<h4>Function sum <a id="sum"/></h4>

<p>Matrix sum</p>

<pre><code>sum :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -&gt; a*P!u per Q!v
</code></pre>

<p>Corresponds with the <code>+</code> operator.</p>

<h4>Function minus <a id="minus"/></h4>

<p>Matrix difference</p>

<pre><code>minus :: for_index D,E: for_unit a,b,c: (a*D!b per E!c, a*D!b per E!c) -&gt; a*D!b per E!c
</code></pre>

<p>Corresponds with the <code>-</code> operator.</p>

<h4>Function inner <a id="inner"/></h4>

<p>The inner product</p>

<pre><code>inner :: for_index P: for_unit a,b,u: (a*P!u, b/P!u) -&gt; a*b
</code></pre>

<p>Satisfies <code>inner(x, y) = x^T .* y</code>.</p>

<h4>Function outer <a id="outer"/></h4>

<p>The outer product</p>

<pre><code>outer :: for_index P,Q: for_unit a,b,u,v: (a*P!u, b*Q!v) -&gt; a*b*P!u per 1/Q!v
</code></pre>

<p>Satisfies <code>outer(x, y) = x .* y^T</code>.</p>

<h4>Function total <a id="total"/></h4>

<p>The sum of the matrix values</p>

<pre><code>total :: for_index P,Q: for_unit a: (a*P! per Q!) -&gt; a
</code></pre>

<p>The matrix must have homogeneous units of measurement.</p>

<h4>Function sqrt <a id="sqrt"/></h4>

<p>Element-wise square root</p>

<pre><code>sqrt :: for_index P,Q: for_unit a,u,v: (a^2*P!u^2 per Q!v^2) -&gt; a*P!u per Q!v
</code></pre>

<p>Matrix with the square root of each element.</p>

<h4>Function ln <a id="ln"/></h4>

<p>Element-wise natural logarithm</p>

<pre><code>ln :: for_index P,Q: (P! per Q!) -&gt; P! per Q!
</code></pre>

<p>Matrix with the natural logarithm of each element.</p>

<h4>Function log <a id="log"/></h4>

<p>Element-wise logarithm</p>

<pre><code>log :: for_index P,Q: (P! per Q!, 1) -&gt; P! per Q!
</code></pre>

<p>Matrix with the logarithm of each element.</p>

<h4>Function abs <a id="abs"/></h4>

<p>The absolute value</p>

<pre><code>abs :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; a*P!u per Q!v
</code></pre>

<p>Matrix with the absolute value of each element.</p>

<h4>Function mod <a id="mod"/></h4>

<p>Element-wise modulo</p>

<pre><code>mod :: for_index P,Q: for_unit a,b,u,v,x,y: (a*P!u per Q!v, b*P!x per Q!y) -&gt; a*P!u per Q!v
</code></pre>

<p>Matrix with the modulo of each corresponding pair of elements.</p>

<h4>Function min <a id="min"/></h4>

<p>Element-wise minimum</p>

<pre><code>min :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -&gt; a*P!u per Q!v
</code></pre>

<p>Matrix with the minimum of each corresponding pair of elements.</p>

<h4>Function max <a id="max"/></h4>

<p>Element-wise maximum</p>

<pre><code>max :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -&gt; a*P!u per Q!v
</code></pre>

<p>Matrix with the maximum of each corresponding pair of elements.</p>

<h4>Function gcd <a id="gcd"/></h4>

<p>Element-wise greatest common divisor</p>

<pre><code>gcd :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -&gt; P! per Q!
</code></pre>

<p>Matrix with the gcd of each corresponding pair of elements.</p>

<h3>Closures <a id="closures"/></h3>

<p><code>
<a href="#left_inverse">left_inverse</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Q!v per a*P!u <br>
<a href="#right_inverse">right_inverse</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Q!v per a*P!u <br>
<a href="#inverse">inverse</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Q!v per a*P!u <br>
<a href="#left_division">left_division</a> :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*P!u per R!w) -> b*Q!v per a*R!w <br>
<a href="#right_division">right_division</a> :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*R!w per Q!v) -> a*P!u per b*R!w <br>
<a href="#kleene">kleene</a> :: for_index P: for_unit u: (P!u per P!u) -> P!u per P!u <br>
<a href="#closure">closure</a> :: for_index P: for_unit u: (P!u per P!u) -> P!u per P!u <br>
</code></p>

<h4>Function left_inverse <a id="left_inverse"/></h4>

<p>The left inverse of a matrix</p>

<pre><code>left_inverse :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; Q!v per a*P!u
</code></pre>

<h4>Function right_inverse <a id="right_inverse"/></h4>

<p>The right inverse of a matrix</p>

<pre><code>right_inverse :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; Q!v per a*P!u
</code></pre>

<h4>Function inverse <a id="inverse"/></h4>

<p>The inverse of a matrix</p>

<pre><code>inverse :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -&gt; Q!v per a*P!u
</code></pre>

<p>The same as <a href="#right_inverse]"><code>right_inverse</code></a>.</p>

<h4>Function left_division <a id="left_division"/></h4>

<p>Left division</p>

<pre><code>left_division :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*P!u per R!w) -&gt; b*Q!v per a*R!w
</code></pre>

<p>Satisfies <code>left_division(x, y) = inverse(x) .* y</code>. Corresponds with the <code>.\</code> operator.</p>

<h4>Function right_division <a id="right_division"/></h4>

<p>Right division</p>

<pre><code>right_division :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*R!w per Q!v) -&gt; a*P!u per b*R!w
</code></pre>

<p>Satisfies <code>right_division(x, y) = x .* inverse(y)</code>. Corresponds with the <code>./</code> operator.</p>

<h4>Function kleene <a id="kleene"/></h4>

<p>Kleene star of a matrix</p>

<pre><code>kleene :: for_index P: for_unit u: (P!u per P!u) -&gt; P!u per P!u
</code></pre>

<h4>Function closure <a id="closure"/></h4>

<p>Transitive closure of a matrix</p>

<pre><code>closure :: for_index P: for_unit u: (P!u per P!u) -&gt; P!u per P!u
</code></pre>

<h3>Trigonometry <a id="trigonometry"/></h3>

<p><code>
<a href="#sin">sin</a> :: for_index P,Q: (radian*P! per Q!) -> P! per Q! <br>
<a href="#cos">cos</a> :: for_index P,Q: (radian*P! per Q!) -> P! per Q! <br>
<a href="#tan">tan</a> :: for_index P,Q: (radian*P! per Q!) -> P! per Q! <br>
<a href="#asin">asin</a> :: for_index P,Q: (P! per Q!) -> radian*P! per Q! <br>
<a href="#acos">acos</a> :: for_index P,Q: (P! per Q!) -> radian*P! per Q! <br>
<a href="#atan">atan</a> :: for_index P,Q: (P! per Q!) -> radian*P! per Q! <br>
<a href="#atan2">atan2</a> :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> radian*P! per Q! <br>
</code></p>

<h4>Function sin <a id="sin"/></h4>

<p>Element-wise sine</p>

<pre><code>sin :: for_index P,Q: (radian*P! per Q!) -&gt; P! per Q!
</code></pre>

<p>Matrix with the sine of each element.</p>

<h4>Function cos <a id="cos"/></h4>

<p>Element-wise cosine</p>

<pre><code>cos :: for_index P,Q: (radian*P! per Q!) -&gt; P! per Q!
</code></pre>

<p>Matrix with the cosine of each element.</p>

<h4>Function tan <a id="tan"/></h4>

<p>Element-wise tangent</p>

<pre><code>tan :: for_index P,Q: (radian*P! per Q!) -&gt; P! per Q!
</code></pre>

<p>Matrix with the tangent of each element.</p>

<h4>Function asin <a id="asin"/></h4>

<p>Element-wise inverse sine</p>

<pre><code>asin :: for_index P,Q: (P! per Q!) -&gt; radian*P! per Q!
</code></pre>

<p>Matrix with the arcsin of each element.</p>

<h4>Function acos <a id="acos"/></h4>

<p>Element-wise inverse cosine</p>

<pre><code>acos :: for_index P,Q: (P! per Q!) -&gt; radian*P! per Q!
</code></pre>

<p>Matrix with the arccos of each element.</p>

<h4>Function atan <a id="atan"/></h4>

<p>Element-wise inverse tangent</p>

<pre><code>atan :: for_index P,Q: (P! per Q!) -&gt; radian*P! per Q!
</code></pre>

<p>Matrix with the arctan of each element.</p>

<h4>Function atan2 <a id="atan2"/></h4>

<p>Element-wise inverse tangent</p>

<pre><code>atan2 :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -&gt; radian*P! per Q!
</code></pre>

<p>Matrix with the atan2 of each corresponding pair of elements.</p>

<h2>List <a id="list"/></h2>

<p><code>
<a href="#empty_list">empty_list</a> :: for_type a: () -> List(a) <br>
<a href="#singleton_list">singleton_list</a> :: for_type a: (a) -> List(a) <br>
<a href="#cons">cons</a> :: for_type a: (a, List(a)) -> List(a) <br>
<a href="#add_mut">add_mut</a> :: for_type a: (List(a), a) -> List(a) <br>
<a href="#append">append</a> :: for_type a: (List(a), List(a)) -> List(a) <br>
<a href="#head">head</a> :: for_type a: (List(a)) -> a <br>
<a href="#tail">tail</a> :: for_type a: (List(a)) -> List(a) <br>
<a href="#list_size">list_size</a> :: for_type a: (List(a)) -> 1 <br>
<a href="#nth">nth</a> :: for_type a: (1, List(a)) -> a <br>
<a href="#zip">zip</a> :: for_type a,b: (List(a), List(b)) -> List(Tuple(a, b)) <br>
<a href="#combis">combis</a> :: for_type a: (List(a)) -> List(Tuple(a, a)) <br>
<a href="#reverse">reverse</a> :: for_type a: (List(a)) -> List(a) <br>
<a href="#naturals">naturals</a> :: (1) -> List(1) <br>
<a href="#map_list">map_list</a> :: for_type a,b: ((a) -> b, List(a)) -> List(b) <br>
<a href="#loop_list">loop_list</a> :: for_type a,b: (a, (a, b) -> a, List(b)) -> a <br>
<a href="#fold_list">fold_list</a> :: for_type a: ((a, a) -> a, List(a)) -> a <br>
</code></p>

<h4>Function empty_list <a id="empty_list"/></h4>

<p>Creates an empty list</p>

<pre><code>empty_list :: for_type a: () -&gt; List(a)
</code></pre>

<p>Satisfies <code>empty_list() = []</code>.</p>

<h4>Function singleton_list <a id="singleton_list"/></h4>

<p>Creates a list with one element</p>

<pre><code>singleton_list :: for_type a: (a) -&gt; List(a)
</code></pre>

<p>For example <code>singleton_list(0) = [0]</code>.</p>

<h4>Function cons <a id="cons"/></h4>

<p>Adds an item to the front of a list</p>

<pre><code>cons :: for_type a: (a, List(a)) -&gt; List(a)
</code></pre>

<p>For example <code>cons(1, [2, 3]) = [1, 2, 3]</code>.</p>

<h4>Function add_mut <a id="add_mut"/></h4>

<p>Adds an element to a list by mutation</p>

<pre><code>add_mut :: for_type a: (List(a), a) -&gt; List(a)
</code></pre>

<p>Returns the original list but with the given item added to it as side-effect. This functions exists for performance reasons only.</p>

<h4>Function append <a id="append"/></h4>

<p>Appends two lists</p>

<pre><code>append :: for_type a: (List(a), List(a)) -&gt; List(a)
</code></pre>

<p>For example <code>append([1, 2], [3, 4, 5]) = [1, 2, 3, 4, 5]</code></p>

<h4>Function head <a id="head"/></h4>

<p>The first element of a list</p>

<pre><code>head :: for_type a: (List(a)) -&gt; a
</code></pre>

<p>For example <code>head([1, 2, 3]) = 1</code>.</p>

<h4>Function tail <a id="tail"/></h4>

<p>A list minus its head</p>

<pre><code>tail :: for_type a: (List(a)) -&gt; List(a)
</code></pre>

<p>Returns a copy of the list but without the first element. For example <code>tail([1, 2, 3]) = [2, 3]</code>.</p>

<h4>Function list_size <a id="list_size"/></h4>

<p>The length of a list</p>

<pre><code>list_size :: for_type a: (List(a)) -&gt; 1
</code></pre>

<p>For example <code>list_size([1, 2, 3]) = 3</code>.</p>

<h4>Function nth <a id="nth"/></h4>

<p>Returns the n-th item from a list</p>

<pre><code>nth :: for_type a: (1, List(a)) -&gt; a
</code></pre>

<p>Indexing starts at zero. For example <code>nth(1, [1, 2, 3]) = 2</code>.</p>

<h4>Function zip <a id="zip"/></h4>

<p>Merges two lists into a list of tuples</p>

<pre><code>zip :: for_type a,b: (List(a), List(b)) -&gt; List(Tuple(a, b))
</code></pre>

<p>The length of the result equals the length of the shortest argument.</p>

<p>For example <code>zip([1, 2, 3], [4, 5, 6, 7, 8]) = [(1, 4), (2, 5), (3, 6)]</code>.</p>

<h4>Function combis <a id="combis"/></h4>

<p>A list with all combinations of a list's elements</p>

<pre><code>combis :: for_type a: (List(a)) -&gt; List(Tuple(a, a))
</code></pre>

<p>For example <code>combis([1, 2, 3]) = [(1, 2), (1, 3), (2, 3)]</code>.</p>

<h4>Function reverse <a id="reverse"/></h4>

<p>Reverse a list</p>

<pre><code>reverse :: for_type a: (List(a)) -&gt; List(a)
</code></pre>

<p>For example <code>reverse([1, 2, 3]) = [3, 2, 1]</code></p>

<h4>Function naturals <a id="naturals"/></h4>

<p>The first n natural numbers</p>

<pre><code>naturals :: (1) -&gt; List(1)
</code></pre>

<p>For example <code>naturals(5) = [0, 1, 2, 3, 4]</code>.</p>

<h4>Function map_list <a id="map_list"/></h4>

<p>Applies a function to the elements of a list</p>

<pre><code>map_list :: for_type a,b: ((a) -&gt; b, List(a)) -&gt; List(b)
</code></pre>

<p>For example <code>map(negative, [1, 2, 3]) = [-1, -2, -3]</code>.</p>

<h4>Function loop_list <a id="loop_list"/></h4>

<p>Folds a list given some initial value</p>

<pre><code>loop_list :: for_type a,b: (a, (a, b) -&gt; a, List(b)) -&gt; a
</code></pre>

<p>For example <code>loop_list(0, lambda(x, y) 2*x + y end, [1, 0, 1, 0, 1, 0]) = 42</code>. See also <a href="#fold_list"><code>fold_list</code></a>.</p>

<h4>Function fold_list <a id="fold_list"/></h4>

<p>Folds a list</p>

<pre><code>fold_list :: for_type a: ((a, a) -&gt; a, List(a)) -&gt; a
</code></pre>

<p>For example <code>fold_list(max, [1, 2, 3, 2, 1]) = 3</code>. See also <a href="#loop_list"><code>loop_list</code></a>.</p>

<hr>

<p>2013 Paul Griffioen</p>
