# ----------------------------------------------------------------------------
# Shell Allometries
#
# An experiment on typed linear algebra for geometry based on:
#
# Urdy S, Goudemand N, Bucher H, Chirat R. 2010. Allometries and the
# morphogenesis of the molluscan shell: a quantitative and theoretical
# model. J. Exp. Zool.  (Mol. Dev. Evol.) 314B:280â€“302.
#
# Paul Griffioen 2012-2014
# ----------------------------------------------------------------------------

module Shells;

include geometry;
include si;
include curve;

# ----------------------------------------------------------------------------
# Type Definitions
# ----------------------------------------------------------------------------

deftype for_unit a: Shell(a) = List(Curve(a));

defalias shell_unit = milli:metre;

defunit millimetre "mm" = milli:metre;
defunit pi "pi" = 3.141592653589793;
defunit degree "deg" = pi/180;

# ----------------------------------------------------------------------------
# Shells
#
# A shell is a tiple (settings, curves, meshes). The settings are derived
# from the shell's parameters. The curves and polygon meshes are computed
# during growth.
# ----------------------------------------------------------------------------

define make_shell(aperture, offset, displacement, roz, mu,
                       growth_constant, theta_x, theta_y, theta_z, segments, fudge) =
  let
      coords = path_coords(aperture, |shell_unit|),
      curve = make_curve([space_vec(x, 0*|shell_unit|, z) | (x, z) <- coords]),
      landmarks = borders(coords),
      s = scale_curve(curve, roz),
      t = translate_curve(s, offset),
      u = transform_curve(t, x_rotation(mu)),
      r = rotation(theta_x, theta_y, theta_z),
      gvm = growth_vector_map(u, displacement, growth_constant, r, landmarks)
  in
      tuple(tuple(u, gvm, growth_constant, segments, landmarks), [], [])
  end;

define get_settings(shell) = 
  let (x, _, _) = shell in x end;

define get_body(shell) =
  let (_, x, _) = shell in x end;
  
define get_meshes(shell) =
  let (_, _, x) = shell in x end;

define shell_current_size(shell) =
  list_size(get_body(shell));

define shell_initial_curve(shell) = 
  let (x, _, _, _, _, _) = get_settings(shell) in x end;

define shell_full_size(shell) = 
  let (_, _, _, _, x, _) = get_settings(shell) in x end;

# ----------------------------------------------------------------------------
# Shell Growth
#
# Call grow(s, n) grows shell s by n segments.
# ----------------------------------------------------------------------------

declare grow :: for_unit a: (Shell(a), 1) -> Shell(a);

declare growth_vector_map ::
  for_unit a: (Curve(a), a*Space!, 1, Space! per Space!, List(1)) -> Curve(a);

declare step :: for_unit a: (Curve(a), Curve(a), 1, List(1)) -> Curve(a);

define grow(shell, n) =
  let
      (settings, body, meshes) = shell,
      (initial, gvm, factor, nr_ticks, landmarks) = settings,
      m = list_size(body)
  in
      begin
          b := [x | x <- body]; # copy for add_mut
          me := [x | x <- meshes]; # copy for add_mut
          s := if m = 0 then initial else last(body) end;
          i := 0;
          while i != n do
              t := step(s, gvm, growth_factor(m+i, factor, nr_ticks), landmarks);
              me := add_mut(me, segment_mesh(s, t));
              b := add_mut(b, t);
              s := t;
              i := i + 1;
          end
          return tuple(settings, b, me);
      end
  end;

define growth_vector_map(curve, translation, growth_constant, rotation, landmarks) =
  let
      inv_rot = inverse(curve_rotation(curve, landmarks)),
      s = scale_curve(curve, growth_constant),
      t = transform_curve(s, rotation),
      u = translate_curve(t, translation),
      diff = sum_curves(u, scale_curve(curve, -1))
  in
      transform_curve(diff, inv_rot)
  end;

define step(curve, gvm, growth_factor, landmarks) =
  let
      r = curve_rotation(curve, landmarks),
      s = scale_curve(gvm, growth_factor)
  in
      sum_curves(curve, transform_curve(s, r))
  end;

define segment_mesh(curveA, curveB) =
  let n = list_size(curveA) in
      tuple(append(curveA, curveB), [tuple(i, mod(i+1, n), n + mod(i+1, n), n + mod(i, n)) | i <- naturals(n)])
  end;

# ----------------------------------------------------------------------------
# Miscellaneous Shell Functions
#
# Function shell_body constructs a polygon mesh outlining a shell
# for the given parameters.
#
# Function axis_point gives a point that is approximately somewhere on
# the coiling axis.
# ----------------------------------------------------------------------------

declare shell_body ::
  (List(Tuple(radian, shell_unit)),
   shell_unit*Space!, shell_unit*Space!,
   1, radian, 1,
   radian, radian, radian, 1, 1) -> Shell(shell_unit);

declare axis_point :: (Shell(shell_unit)) -> shell_unit*Space!;

define shell_body(aperture, offset, displacement, roz, mu,
                       growth_constant, theta_x, theta_y, theta_z, segments, fudge) =
  grow(make_shell(aperture, offset, displacement, roz, mu,
                       growth_constant, theta_x, theta_y, theta_z, segments, fudge), segments);

define axis_point(shell) =
  let body = get_body(shell) in
      if body = [] then
          0 . |shell_unit*Space!|
      else
          sum[ curve_nth(0, x) | x <- body] /. list_size(body)
      end
  end;

# ----------------------------------------------------------------------------
# Shell Info 
#
# A shell's info is a tuple with information about the shell:
#   - aperture area
#   - body area growth
#   - body area
#   - body volume growth
#   - body_volume
# ----------------------------------------------------------------------------

define empty_shell_info() =
  tuple([0*|shell_unit^2|], [0*|shell_unit^2|], [0*|shell_unit^2|], [0*|shell_unit^3|], [0*|shell_unit^3|]);

define extend_shell_info(shell, info, n) =
  let
     (aperture_area, body_area_growth, body_area, body_volume_growth, body_volume) = info,
      body = get_body(shell) 
  in
      begin
          start := list_size(aperture_area) - 1;
          i := 0;
          area := last(body_area);
          volume := last(body_volume);
          while i != n do
              a := nth(max(0, start+i-1), body);
              b := nth(start+i, body);
              cb := curve_surface(reverse(b));
              ss := segment_surface(a, b);
              sass := surface_area(ss);
              area := area + sass;
              vss := surface_volume(append(ss, append(curve_surface(a), cb)));
              volume := volume + vss;
              aperture_area := add_mut(aperture_area, surface_area(cb));
              body_area_growth := add_mut(body_area_growth, sass);
              body_area := add_mut(body_area, area);
              body_volume_growth := add_mut(body_volume_growth, vss);
              body_volume := add_mut(body_volume, volume);
              i := i + 1;
          end
          return tuple(aperture_area, body_area_growth, body_area, body_volume_growth, body_volume);
      end
  end;

define last_segment_info(info) =
  let (aperture_area, body_area_growth, body_area, body_volume_growth, body_volume) = info in
      tuple(last(aperture_area), last(body_area_growth), last(body_area), last(body_volume_growth), last(body_volume))
  end;

# ----------------------------------------------------------------------------
# Apertures
#
# This interface provides convenience functions to create circular and
# rectangular apertures. The Shell interface expects a list of
# (angle, distance) pairs as initial aperture. Such pairs outline a
# path in the x-z plane. The functions in this section create such
# paths.
#
# Application circle_path(n, d) creates a circle of n line segments
# each of lenght d. Call rectangle_path(w, h) creates a rectangle of
# width w and height h.
# ----------------------------------------------------------------------------

declare circle_path :: for_unit a: (1, a) -> List(Tuple(radian, a));
declare rectangle_path :: for_unit a: (a, a) -> List(Tuple(radian, a));
declare path_coords :: for_unit a: (List(Tuple(radian, a)), a) -> List(Tuple(a, a));
declare borders :: for_unit a: (List(Tuple(a, a))) -> List(1);

define circle_path(n, d) =
  let angle = 2*pi*|radian|/n in
    [tuple(a, d) | i <- naturals(n-1), a := if i = 0 then angle/2 else angle end]
  end;

define rectangle_path(w, h) =
  let turn = pi*|radian|/2 in
    [tuple(0*|radian|, h/2), tuple(turn, w), tuple(turn, h), tuple(turn, w)]
  end;

define path_coords(path, unit) =
  begin
      x := 0*unit;
      y := 0*unit;
      direction := 0*|radian|;
      coords := [tuple(x,y)];
      while path != [] do
          (angle, distance) := head(path);
          direction := direction + angle;
          x := x + distance * sin(direction);
          y := y + distance * cos(direction);
          coords := cons(tuple(x, y), coords);
          path := tail(path);
      end
      return coords;
  end;

define borders(coords) =
  let
      indices = naturals(list_size(coords)),
      x_less(a, b) = let (xa, ya) = a, (xb, yb) = b in xa < xb end,
      y_less(a, b) = let (xa, ya) = a, (xb, yb) = b in ya < yb end,
      left = fold_list(lambda (i,j) if x_less(nth(i, coords), nth(j, coords)) then i else j end end, indices),
      top = fold_list(lambda (i,j) if y_less(nth(i, coords), nth(j, coords)) then i else j end end, indices),
      right = fold_list(lambda (i,j) if x_less(nth(i, coords), nth(j, coords)) then j else i end end, indices),
      bottom = fold_list(lambda (i,j) if y_less(nth(i, coords), nth(j, coords)) then j else i end end, indices)
  in
    [left, top, right, bottom]
  end;

# ----------------------------------------------------------------------------
# Size factors
# ----------------------------------------------------------------------------

declare growth_factor :: (1, 1, 1) -> 1;
declare growth_factors :: (1, 1) -> List(1);

#define growth_factor(t, growth_constant, nr_ticks) = 1;

#define growth_factor(t, growth_constant, nr_ticks) =  expt(growth_constant, t);

define growth_factor(t, growth_constant, nr_ticks) =
  let 
      r = ln(growth_constant),
      k = 2*exp(r*nr_ticks/2) 
  in
    if r = 0 then 
        1
    else
        (logistic(r, t+1, k, 1) - logistic(r, t, k, 1)) /
        (logistic(r, 1, k, 1) - logistic(r, 0, k, 1))
    end
  end;

define logistic(r, t, k, y) =
  k*y / ((k-y) * exp(-r*t) + y);

define growth_factors(growth_constant, n) =
  [growth_factor(t, growth_constant, n) | t <- naturals(n)];

# ----------------------------------------------------------------------------
# A test
# ----------------------------------------------------------------------------

define my_path_a() = circle_path(17, 0.2*|shell_unit|);

define my_path_b() = [tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.6*|radian|, 0.25*|shell_unit|),
                      tuple(-0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.6*|radian|, 1.25*|shell_unit|),
                      tuple(-0.6*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|),
                      tuple( 0.3*|radian|, 0.25*|shell_unit|)];

define my_path_c() = rectangle_path(0.5*|shell_unit|, 0.5*|shell_unit|);

let 
    deg = 2*pi*|radian|/360,
    shell_vec(x, y, z) = space_vec(x*|shell_unit|, y*|shell_unit|, z*|shell_unit|)
in
    shell_body(my_path_a(), shell_vec(0, 0, 0), shell_vec(-0.05, 0, -0.02),
                   1, 0*deg, 1.02, 0*deg, 0*deg, 10*deg, 2, 1)
end;

# ----------------------------------------------------------------------------
# General Utilities
# ----------------------------------------------------------------------------

define last(x) = nth(list_size(x)-1, x);
