# ----------------------------------------------------------------------------
# Shell Curves
#
# Paul Griffioen 2012-2013
# ----------------------------------------------------------------------------

module Curve;

include geometry;

# ----------------------------------------------------------------------------
# Signature
# ----------------------------------------------------------------------------

deftype for_unit a: Curve(a) = List(a*Space!);

declare make_curve :: for_unit a: (List(a*Space!)) -> Curve(a);

declare curve_nth :: for_unit a: (1, Curve(a)) -> a*Space!;

declare translate_curve :: for_unit a: (Curve(a), a*Space!) -> Curve(a);

declare transform_curve :: for_unit a,b: (Curve(a), b*Space! per Space!) -> Curve(a*b);

declare sum_curves :: for_unit a: (Curve(a), Curve(a)) -> Curve(a);

declare scale_curve :: for_unit a,b: (Curve(a), b) -> Curve(a*b);

declare curve_surface :: for_unit a: (Curve(a)) -> List(Tuple(a*Space!, a*Space!, a*Space!));

declare segment_surface :: for_unit a: (Curve(a), Curve(a)) -> List(Tuple(a*Space!, a*Space!, a*Space!));

declare segment_closed_surface :: for_unit a: (Curve(a), Curve(a)) -> List(Tuple(a*Space!, a*Space!, a*Space!));

declare segment_area :: for_unit a: (Curve(a), Curve(a)) -> a^2;

declare segment_volume :: for_unit a: (Curve(a), Curve(a)) -> a^3;

declare compute_rotation :: for_unit a: (a*Space!, a*Space!, a*Space!, a*Space!) -> Space! per Space!;

declare curve_rotation :: for_unit a: (Curve(a), List(1)) -> Space! per Space!;

# ----------------------------------------------------------------------------
# Curves
# ----------------------------------------------------------------------------

define make_curve(vs) = append(vs, [head(vs)]);

define curve_nth(i, curve) = nth(i, curve);

define translate_curve(curve, offset) =
  [ x + offset | x <- curve];

define transform_curve(curve, matrix) =
  [ matrix .* x | x <- curve];

define sum_curves(x, y) =
  [ a+b | (a,b) <- zip(x,y)];

define scale_curve(curve, factor) =
  [ factor . x | x <- curve];

define curve_surface(curve) =
  let n = list_size(curve) - 1 in
      if n < 3 then [] else
	  let first = nth(0, curve) in
	      [ tuple(first, nth(i + 1, curve), nth(i + 2, curve)) | i <- naturals(n - 2)]
	  end
      end
  end;

define segment_surface(curve, next) =
  let n = list_size(curve) in
      if n < 2 then [] else
          append([ tuple(nth(i, curve), nth(i, next), nth(i+1, curve)) | i <- naturals(n - 1)],
		 [ tuple(nth(i, next), nth(i+1, next), nth(i+1, curve)) | i <- naturals(n - 1)])
      end
  end;

define segment_closed_surface(curve, next) =
  append(segment_surface(curve, next),
	 append(curve_surface(curve), curve_surface(reverse(next))));

define segment_area(curve, next) =
  surface_area(segment_surface(curve, next));

define segment_volume(curve, next) =
  surface_volume(segment_closed_surface(curve, next));

define curve_rotation(curve, landmarks) =
  compute_rotation(nth(nth(0, landmarks), curve),
		   nth(nth(1, landmarks), curve),
		   nth(nth(2, landmarks), curve),
		   nth(nth(3, landmarks), curve));

define compute_rotation(left, top, right, bottom) =
  let
      width = right - left,
      height = top - bottom
  in magnitude(
      normalized(width) .* d_x^T +
      normalized(cross_sqrt(width, height)) .* d_y^T +
      normalized(height) .* d_z^T )
  end;
