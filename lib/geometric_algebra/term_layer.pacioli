import geometry;

# ----------------------------------------------------------------------------
# The context
#
# A context defines all blades, their names and the order for an instances
# of geometric algebra.
#
# For example a context for two-dimensional geometry could be defined by:
#
# define context_2d =
#    make_context("My 2D context!!!", [
#        tuple("1", []),
#        tuple("e1", [base1]),
#        tuple("e2", [base2]),
#        tuple( "e12", [base1, base2]),
#    ]);
# 
# where base1 and base2 are some base vectors.
# ----------------------------------------------------------------------------

deftype for_index I: for_unit a:
    Context(a, I!) = Tuple(String, List(Tuple(String, List(a * I!))));

declare export make_context :: for_index I: for_unit a:
    (String, List(Tuple(String, List(a * I!)))) -> Context(a, I!);

declare context_blades :: for_index I: 
    (Context(1, I!)) -> List(BaseBlade(1, I!));

declare context_name :: for_index I: for_unit a: (Context(a, I!)) -> String;
declare context_size :: for_index I: for_unit a: (Context(a, I!)) -> 1;

declare context_blade_name :: for_index I: for_unit a:
    (Context(a, I!), 1) -> String;

declare context_blade_vectors :: for_index I: for_unit a:
    (Context(a, I!), 1) -> List(a*I!);

declare context_product :: for_index I: for_unit a,b:
    (Context(a, I!), Context(b, I!)) -> Context(a*b, I!);

# Constructor for contexts. The name is an arbitrary string. The names
# and vectors is a list of pairs (x, vs) with x a description of a
# blade and vs the blade's vectors.

# ----------------------------------------------------------------------------

doc make_context
    "Constructor for contexts. The name is an arbitrary string. The
    names and vectors is a list of pairs (x, vs) with x a description
    of a blade and vs the blade's vectors.";

define make_context(name, names_and_vectors) =
    tuple(name, names_and_vectors);

# ----------------------------------------------------------------------------

doc context_blades
    "A list of all blades in the context. The blades are constructed
    from the names and vectors passed to the constructor.";

define context_blades(context) = 
    [make_base_blade(i, context) | i <- naturals(context_size(context))];

# ----------------------------------------------------------------------------

doc context_name
    "The name of a context that was passed to the constructor.";

define context_name(context) =
    let (name, _) = context in name end;

# ----------------------------------------------------------------------------

doc context_size
    "The number of blades in a context. Equals the size of the names
    and vectors list that was passed to the constructor.";

define context_size(context) =
    let (_, info) = context in
        list_size(info)
    end;

# ----------------------------------------------------------------------------

doc context_blade_name
    "Looks up a blade's name in the context from a given blade
    position. The position must be less than the context size.";

define context_blade_name(context, i) =
    let 
        (_, info) = context,
        (name, _) = nth(i, info)
    in
        name
    end;

# ----------------------------------------------------------------------------

doc context_blade_vectors
    "Looks up a blade's vectors in the context from a given blade
    position. The position must be less than the context size.";

define context_blade_vectors(context, i) =
    let
        (_, info) = context,
        (_, vectors) = nth(i, info)
    in
        vectors
    end;

# ----------------------------------------------------------------------------

define context_product(a_context, b_context) =
    let (_, a_info) = a_context,
        (_, b_info) = b_context
    in
        make_context(
            concatenate(context_name(a_context), context_name(b_context)),
            zip_with((t1, t2) -> product_tuples(t1, t2), a_info, b_info))
    end;

# ----------------------------------------------------------------------------

define product_tuples(t1, t2) = 
    let (name1, bases_1) = t1,
        (_, bases_2) = t2
    in
        tuple(name1, zip_with((b1, b2) -> b1*b2, bases_1, bases_2))
    end;

# ----------------------------------------------------------------------------
# Representation of Base Blades layer
#
# Given some context c, a blade is a pair (i, c) with i an index into the list 
# of names and vectors c. The index tells which blade it is.
#
# The information about the geometry instance that we are working with is thus
# carried in each blade. This context is needed for the inner, the geometric and
# the outer product and for printing. By storing it in each blade the code
# at higher levels does not have to see it.
#
# Alternatively we could generate code for the various GA instances. In
# that case the information can be hard-coded in the generated code instead
# of carrying it in the blades.
# ----------------------------------------------------------------------------

declare make_base_blade :: for_index I: (1, Context(1, I!)) -> BaseBlade(1, I!);

declare base_blade_position :: for_index I: for_unit a: (BaseBlade(a, I!)) -> 1;
declare base_blade_context :: for_index I: for_unit a: (BaseBlade(a, I!)) -> Context(a, I!);
declare base_blade_name :: for_index I: for_unit a: (BaseBlade(a, I!)) -> String;
declare export base_blade_vectors :: for_index I: for_unit a: (BaseBlade(a, I!)) -> List(a * I!);

declare scalar_base_blade :: for_index I:  (Context(1, I!)) -> BaseBlade(1, I!);
declare is_scalar_base_blade :: for_index I: for_unit a: (BaseBlade(a, I!)) -> Boole;

declare export blade_grade :: for_index I: for_unit a: (BaseBlade(a, I!)) -> 1;

declare compare_base :: for_index I: for_unit a: (BaseBlade(a, I!), BaseBlade(a, I!)) -> 1;


deftype for_index I: for_unit a: BaseBlade(a, I!) =
    Tuple(1, Context(a, I!));

define make_base_blade(position, context) =
    tuple(position, context);

define base_blade_position(base_blade) = 
    let (position, _) = base_blade in position end;

define base_blade_context(base_blade) = 
    let (_, context) = base_blade in context end;
    
define base_blade_name(base_blade) = 
    context_blade_name(base_blade_context(base_blade), base_blade_position(base_blade));

define base_blade_vectors(base_blade) = 
    context_blade_vectors(base_blade_context(base_blade), base_blade_position(base_blade));

define scalar_base_blade(context) =
    make_base_blade(0, context);

define is_scalar_base_blade(blade) =
    base_blade_position(blade) = 0;

define blade_grade(n) =
    list_size(base_blade_vectors(n));

define compare_base(x, y) =
    compare(base_blade_position(x), base_blade_position(y));

# ----------------------------------------------------------------------------
# Term layer: weighted Blades
#
# Term is represented using a 2-tuple (w,b) in which
#   w represents its weight
#   b represents the base blade number
# Examples: (5,0) represents the (weighted) blade 5e0. (3,2) represents 3e2.
#
#
# Ordering for comparing and ordering blades (<,=,>):
# The result is currently simply represented as -1 | 0 | 1 respectively.
#
# @@@ Could be Ordering = LT | GT | EQ.
# ----------------------------------------------------------------------------

deftype for_index I: for_unit a:
    Term(a, I!) = Tuple(a, BaseBlade(1, I!));

# ----------------------------------------------------------------------------

doc make_term
    "Constructs a term from a weight and a base blade.";

declare export make_term :: for_index I: for_unit a:
    (a, BaseBlade(1, I!)) -> Term(a, I!);

define make_term(weight, blade) =
    tuple(weight, blade);

# ----------------------------------------------------------------------------

doc term_weight
    "A term's weight. Satisfies <code>term_weight(make_term(w, b)) = w</code>";

declare export term_weight :: for_index I: for_unit a:
    (Term(a, I!)) -> a;

define term_weight(term) =
    let (weight, _) = term in weight end;

#declare export term_weight_unit_inverse :: for_index I: for_unit a: (Term(a, I!)) -> a^-1;

define term_weight_unit_inverse(term) =
    let (weight, _) = term,
        w = magnitude(weight)
    in
        w * w / weight
    end;

# ----------------------------------------------------------------------------

doc term_base_blade
    "A term's base blade. Satisfies <code>term_base_blade(make_term(w, b)) = b</code>.";

declare export term_base_blade :: for_index I: for_unit a:
    (Term(a, I!)) -> BaseBlade(1, I!);

define term_base_blade(term) =
    let (_, blade) = term in blade end;

# ----------------------------------------------------------------------------

doc term_grade
    "A term's grade. Scalars are grade 0, vectors are grade 1,
    bi-vectors are grade 2. In general a k-vector has grade k.";

declare export term_grade :: for_index I: for_unit a:
    (Term(a, I!)) -> 1;

define term_grade(term) =
    blade_grade(term_base_blade(term));

# ----------------------------------------------------------------------------

doc scale_term
    "Scales a term with a factor. Multiplies the term's weight with the
    given number.";

declare export scale_term :: for_index I: for_unit a,b:
    (a, Term(b, I!)) -> Term(a*b, I!);

define scale_term(a, term) =
    let (weight, blade) = term in make_term(a * weight, blade) end;

# ----------------------------------------------------------------------------

doc term_product
    "Product of two terms. When the third argument is true it is the
    geometric product, otherwise it is the outer product.";

declare export term_product :: for_index I: for_unit a,b:
    (Term(a, I!), Term(b, I!), Boole) -> Term(a*b, I!);

define term_product(x, y, no_common) =
    let
        x_context = base_blade_context(term_base_blade(x)),
        y_context = base_blade_context(term_base_blade(y)),
        context = context_product(x_context, y_context),
        x_bin = int2bin(base_blade_position(term_base_blade(x))),
        y_bin = int2bin(base_blade_position(term_base_blade(y)))
    in
         let
            wx = term_weight(x),
            wy = term_weight(y),
            sign = mod(count_swap(x_bin, y_bin), 2),
            weight = if sign = 0 then wx * wy else -wx * wy end,
            blade = make_base_blade(bin2int(bit_list_xor(x_bin, y_bin)), context)
        in
            if no_common and some[b != 0 | b <- bit_list_and(x_bin, y_bin)] then
                # @@@TODO: scalar_base_blade necessary or should blade suffice?
                #scale_term(0, make_term(weight, scalar_base_blade(context)))
                scale_term(0, make_term(weight, blade))
             else
                make_term(weight, blade)
            end
        end
    end;

# ----------------------------------------------------------------------------

doc term_reverse 
    "Reverses a term. Changes the sign of the term depending on the term's 
    grade according to the following pattern: ++--++--++--.
    
    So terms with grade 0 or 1 don't get their sign changed, terms with 
    grade 2 or 3 do get their sign changed, and so on.";

declare export term_reverse :: for_index I: for_unit a:
    (Term(a, I!)) -> Term(a, I!);

define term_reverse(term) =
  # p.519 Leo (++--++--++-- pattern for reversion)
    let
        modulus = mod(term_grade(term), 4)
    in
        if modulus = 0 or modulus = 1 then
            term
        else
            scale_term(-1, term)
            #make_term(-1 * term_weight_unit_inverse(term), term_base_blade(term))
        end
    end;

# ----------------------------------------------------------------------------

doc term_inverse
    "Leo's inverse formula 6.24 p155. NB: units TODO";

# TODO invert the unit
declare export term_inverse :: for_index I: for_unit a:
    (Term(a, I!)) -> Term(a^-1, I!);

define term_inverse(term) = 
    let
        rev_term = term_reverse(term),
        term_prod = term_product(term, rev_term, false)
    in
        make_term(term_weight(rev_term) / term_weight(term_prod), term_base_blade(rev_term))
    end;

# ----------------------------------------------------------------------------

doc term_bar
    "Grade involution for a term.
    
    Changes the sign of the term depending on the term's grade according to the
    following pattern: +-+-+-+-+-+-. So terms with even grade don't get their
    sign changed and terms with odd grade do get their sign changed.";

declare export term_bar :: for_index I: for_unit a:
    (Term(a, I!)) -> Term(a, I!);

define term_bar(term) =
    if mod(term_grade(term), 2) = 0 then
        term
    else
        scale_term(-1, term)
    end;

# ----------------------------------------------------------------------------

declare export compare_term :: for_index I: for_unit a:
    (Term(a, I!), Term(a, I!)) -> 1;

define compare_term(x, y) =
    let grade_comparison = compare(term_grade(x), term_grade(y)) in
        if grade_comparison = 0 then
            compare_base(term_base_blade(x), term_base_blade(y))
        else
            grade_comparison
        end
    end;

# ----------------------------------------------------------------------------

doc term_inner_product
    "The inner product between terms. Equals the geometric product, unless
    the predicate of the third argument is true. In that case the result
    is zero. The predicate receives the grades of the terms and the geometric
    product as arguments.

    @@@ TODO Leo's ArrayList...

    See Leo's code MODIFIED_HESTENES_INNER_PRODUCT - in BasisBlade innerProductFilter
    https://geometricalgebra.org/ga_ref_impl/subspace/basis/BasisBlade.java.html#inner_product_filter";
    
declare term_inner_product :: for_index I: for_unit a,b:
    (Term(a, I!), Term(b, I!), (1, 1, Term(a*b, I!)) -> Boole) -> Term(a*b, I!);

define term_inner_product(t1, t2, predicate) = 
    let res = term_geometric_product(t1, t2) in
        if predicate(term_grade(t1), term_grade(t2), res) then
            res
        else
            scale_term(0, res) #make_term(0, scalar_base_blade(base_blade_context(term_base_blade(res))))
        end
    end;

# ----------------------------------------------------------------------------

doc term_geometric_product
    "The geometric product between terms.

    @@@TODO: scale AND-ed terms using Metric double array according to Leo's code

    https://geometricalgebra.org/ga_ref_impl/subspace/basis/BasisBlade.java.html#geometricProduct";

declare term_geometric_product :: for_index I: for_unit a,b:
    (Term(a, I!), Term(b, I!)) -> Term(a*b, I!);

define term_geometric_product(t1, t2) = 
    term_product(t1, t2, false);

# ----------------------------------------------------------------------------
# Just needed for term_product
# ----------------------------------------------------------------------------

deftype ReversedBitList() = List(1);

declare int2bin :: (1) -> ReversedBitList;

define int2bin(n) =
    if n=0 then
        [0]
    else if n=1 then
        [1]
    else if mod(n, 2) = 0 then
        cons(0, int2bin(div(n, 2)))
    else
        cons(1, int2bin(div(n-1, 2)))
    end;

declare bin2int :: for_index I: for_unit a: 
    (ReversedBitList) -> 1;

define bin2int(xs) =
    if xs = [0] then
        0
    else if xs = [1] then
        1
    else
        head(xs) + 2*bin2int(tail(xs))
    end;

declare bit_list_and, bit_list_xor :: (ReversedBitList, ReversedBitList) -> ReversedBitList;

define bit_list_xor(xs, ys) =
    if ys = [] then
        xs
    else if xs = [] then
        ys
    else
        cons(mod(head(xs) + head(ys), 2), bit_list_xor(tail(xs), tail(ys)))
    end;

define bit_list_and(xs, ys) =
  zip_with((x, y) -> x * y, xs, ys);

define count_swap(xs, ys) =
    let
        m = list_size(xs),
        n = list_size(ys)
    in
        count[ nth(i, xs) * nth(j, ys) = 1 | i <- naturals(m), j <- naturals(min(i, n))]
    end;
