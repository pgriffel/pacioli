# ------------------------------------------------------------------------------
# 3D graphics
# ------------------------------------------------------------------------------

import geometry;

export
    Mesh,
    Arrow,
    Path,
    Vertex,
    Face,
    Scene,
    SceneElts,
    empty_scene, 
    add_updater,
    get_arrows,
    set_arrows,
    get_meshes,
    set_meshes,
    add_arrows,
    add_meshes,
    add_paths,
    make_path,
    make_line,
    make_mesh,
    move_mesh,
    cube_mesh,
    named_cube_mesh,
    vertex,
    face,
    set_wireframe,
    make_arrow,
    named_arrow,
    origin_arrow,
    move_arrow,
    arrow_color,
    set_arrow_color;

# ------------------------------------------------------------------------------
# Scene elements
# ------------------------------------------------------------------------------

deftype for_unit a: SceneElts(a) = 
    Tuple(
        List(Arrow(a)),
        List(Mesh(a)),
        List(Path(a)));

declare get_arrows :: for_unit a: (SceneElts(a)) -> List(Arrow(a));
declare set_arrows :: for_unit a: (SceneElts(a), List(Arrow(a))) -> SceneElts(a);

define get_arrows(data) =
    let (vectors, _, _) = data in
        vectors
    end;

define set_arrows(data, vectors) =
    let (_, meshes, paths) = data in
        tuple(vectors, meshes, paths)
    end;

declare get_meshes :: for_unit a: (SceneElts(a)) -> List(Mesh(a));
declare set_meshes :: for_unit a: (SceneElts(a), List(Mesh(a))) -> SceneElts(a);

define get_meshes(data) =
    let (_, meshes, _) = data in
        meshes
    end;

define set_meshes(data, meshes) =
    let (vectors, _, paths) = data in
        tuple(vectors, meshes, paths)
    end;

# ------------------------------------------------------------------------------
# Building a scene
# ------------------------------------------------------------------------------

doc Scene
    "A scene is a geometric space that can contain vectors, meshes and paths. It 
    is a space with vectors of type <code>a*Geom3!</code>.
    
    Currently it can only be displayed in a browser.";

deftype for_unit a: Scene(a) = 
    Tuple(
        String,
        SceneElts(a),
        Maybe((1, SceneElts(a)) -> SceneElts(a)));

# ------------------------------------------------------------------------------

doc empty_scene
    "Constructs a scene.
    
    The argument is a description of the scene that can be used as a caption.";

declare empty_scene ::
    for_unit a: (String) -> Scene(a);

define empty_scene(description) =
    tuple(description, tuple([], [], []), nothing());

# ------------------------------------------------------------------------------

declare add_updater ::
    for_unit a: (Scene(a), (1, SceneElts(a)) -> SceneElts(a)) -> Scene(a);

define add_updater(scene, callback) =
    let (description, data, _) = scene in
        tuple(description, data, just(callback))
    end;

# ------------------------------------------------------------------------------

doc add_arrows
    "Adds arrows to a scene";

declare add_arrows ::
    for_unit a: (List(Arrow(a)), Scene(a)) -> Scene(a);

define add_arrows(vs, scene) =
    let (description, elements, callback) = scene in
        tuple(
            description,
            set_arrows(elements, append(vs, get_arrows(elements))),
            callback)
    end;


# ------------------------------------------------------------------------------

doc add_meshes
    "Adds meshes to a scene";

declare add_meshes ::
    for_unit a: (List(Mesh(a)), Scene(a)) -> Scene(a);

define add_meshes(ms, scene) =
    let (description, data, callback) = scene in
        let (vectors, meshes, paths) = data in
            tuple(description, tuple(vectors, append(ms, meshes), paths), callback)
        end
    end;

# ------------------------------------------------------------------------------

doc add_paths
    "Adds paths to a scene";

declare add_paths ::
    for_unit a: (List(Path(a)), Scene(a)) -> Scene(a);

define add_paths(ps, scene) =
    let (description, data, callback) = scene in
        let (vectors, meshes, paths) = data in
            tuple(description, tuple(vectors, meshes, append(ps, paths)), callback)
        end
    end;

# ------------------------------------------------------------------------------
# Path
# ------------------------------------------------------------------------------

doc Path
    "A series of lines between succesive points. Is an element of a 
    <code>Scene(a)</code> scene.";

deftype for_unit a:
    Path(a) = List(a * Geom3!);

# ------------------------------------------------------------------------------

doc make_path
    "Constructs a path from a list of points.";

declare make_path ::
    for_unit a: (List(a * Geom3!)) -> Path(a);

define make_path(vecs) =
    vecs;

# ------------------------------------------------------------------------------

doc make_line
    "A line between two points. Each point is indicated by a vector.";

declare make_line ::
    for_unit a: (a * Geom3!, a * Geom3!) -> Path(a);

define make_line(v0, v1) =
    make_path([v0, v1]);

# ------------------------------------------------------------------------------
# Mesh
# ------------------------------------------------------------------------------

doc Mesh
    "A 3D shape composed from faces and vertices. Is an element of a 
    <code>Scene(a)</code> scene.";

deftype for_unit a:
    Mesh(a) = Tuple(
                List(Tuple(a*Geom3!, String)),
                List(Tuple(1, 1, 1)),
                a*Geom3!,
                Maybe(String),
                Boole);

doc Vertex
    "A point in a <code>Mesh(a)</code> mesh.";

deftype for_unit a:
    Vertex(a) = Tuple(a*Geom3!, String);

doc Face
    "A suface between a mesh's vertices.";

deftype 
    Face() = Tuple(1, 1, 1);

# ------------------------------------------------------------------------------

doc vertex
    "Creates a mesh vertex. Expects x, y and z coordinates and a color. Is an 
    element of a <code>Scene(a)</code> scene.";

declare vertex :: for_unit a: (a * Geom3!, String) -> Vertex(a);

define vertex(vec, color) =
    tuple(vec, color);

# ------------------------------------------------------------------------------

doc face
    "Creates a mesh face. Each argument is the index of a vertex. The mesh must
    contains sufficient vertices.";

declare face :: (1, 1, 1) -> Face;

define face(i, j, k) =
    tuple(i, j, k);

# ------------------------------------------------------------------------------

doc make_mesh
    "Creates a mesh from vertices and faces";

declare make_mesh :: for_unit a: (List(Vertex(a)), List(Face)) -> Mesh(a);

define make_mesh(vertices, faces) = 
    tuple(vertices, faces, 0 '.*' let (v,_) = nth(0, vertices) in v end, nothing(), false);

declare named_mesh :: for_unit a: (List(Vertex(a)), List(Face), String) -> Mesh(a);

define named_mesh(vertices, faces, name) = 
    tuple(vertices, faces, 0 '.*' let (v,_) = nth(0, vertices) in v end, just(name), false);

declare set_wireframe :: for_unit a: (Mesh(a), Boole) -> Mesh(a);

define set_wireframe(mesh, status) = 
  let (vs, fs, pos, name, _) = mesh in tuple(vs, fs, pos, name, status) end;

# ------------------------------------------------------------------------------

doc cube_mesh
    "Creates a cube mesh, a mesh with lengths of 'size' positioned at the origin.";

declare named_cube_mesh :: for_unit a: (String, a) -> Mesh(a);

define named_cube_mesh(name, size) =
    make_cube_mesh(just(name), size);

define make_cube_mesh(name, size) =
    let
        c = "lightgreen",
        vertices = [vertex(space_vec(0,0,0),c),
                    vertex(space_vec(1,0,0),c),
                    vertex(space_vec(1,0,1),c),
                    vertex(space_vec(0,0,1),c),
                    vertex(space_vec(0,1,0),c),
                    vertex(space_vec(1,1,0),c),
                    vertex(space_vec(1,1,1),c),
                    vertex(space_vec(0,1,1),c)],
        faces = [
            face(0,2,1),
            face(0,3,2),                 
            face(4,5,6),                                
            face(4,6,7),                                                
            face(0,5,4),                
            face(0,1,5),                                                                
            face(1,6,5),                
            face(1,2,6),                
            face(2,7,6),                
            face(2,3,7),
            face(3,4,7), 
            face(3,0,4)
        ]
    in
        tuple([tuple(size '.*' x, c) | (x, c) <- vertices], faces, 0 '.*' size '.*' space_vec(0,0,0), name, false)
    end;

declare cube_mesh :: for_unit a: (a) -> Mesh(a);

define cube_mesh(size) =
    make_cube_mesh(nothing(), size);

# ------------------------------------------------------------------------------

doc move_mesh
    "Moves a mesh by offset 'vec'";

declare move_mesh :: for_unit a: (Mesh(a), a*Geom3!) -> Mesh(a);

define move_mesh(mesh, vec) =
    let (vertices, faces, pos, name, wireframe) = mesh in
        tuple(vertices, faces, pos + vec, name, wireframe)
    end;

# ------------------------------------------------------------------------------
# Arrow
# ------------------------------------------------------------------------------

doc Arrow
    "An arrow is a colored line segment from from one position to another,
    with an arrowhead at the end. Is an element of a <code>Scene(a)</code> 
    scene.";

deftype for_unit a:
    Arrow(a) = Tuple(a*Geom3!, a*Geom3!, String, Maybe(String));

# ------------------------------------------------------------------------------

doc make_arrow
    "Creates an arrow between two points.";

declare make_arrow ::
    for_unit a: (a*Geom3!, a*Geom3!, String) -> Arrow(a);

define make_arrow(from, to, color) =
    tuple(from, to, color, nothing());

declare named_arrow ::
    for_unit a: (a*Geom3!, a*Geom3!, String, String) -> Arrow(a);

define named_arrow(from, to, color, name) =
    tuple(from, to, color, just(name));

# ------------------------------------------------------------------------------

doc origin_arrow
    "Creates an arrow from the origin to some point.";

declare origin_arrow :: for_unit a: (a*Geom3!, String) -> Arrow(a);

define origin_arrow(vector, color) =
    make_arrow(0 '.*' vector, vector, color);

# ------------------------------------------------------------------------------

declare move_arrow :: for_unit a: (Arrow(a), a * Geom3!) -> Arrow(a);

define move_arrow(arrow, position) =
    let (from, to, color, name) = arrow in
        tuple(from + position, to + position, color, name)
    end;

declare set_arrow_color :: for_unit a: (Arrow(a), String) -> Arrow(a);

define set_arrow_color(arrow, color) =
    let (from, to, _, name) = arrow in
        tuple(from, to, color, name)
    end;

declare arrow_color :: for_unit a: (Arrow(a)) -> String;

define arrow_color(arrow) =
    let (_, _, color, _) = arrow in
        color
    end;

# ------------------------------------------------------------------------------
# Parallelogram
# ------------------------------------------------------------------------------

doc Parallelogram
    "A parallelogram is a tuple (vector1, vector2, color). It is a colored area 
    spanned by the two vectors. Is an element of a <code>Scene(a)</code> scene.

    Unused at the moment";

deftype for_unit a:
    Parallelogram(a) = Tuple(a*Geom3!, a*Geom3!, String);

# ------------------------------------------------------------------------------

doc make_parallelogram
    "A colored parallelogram spanned by vector1 and vector2";

declare make_parallelogram ::
    for_unit a: (a*Geom3!, a*Geom3!, String) -> Parallelogram(a);

define make_parallelogram(vector1, vector2, color) =
    tuple(vector1, vector2, color);

# ------------------------------------------------------------------------------

doc move_parallelogram
    "Change the parallelogram's position by delta";
    
declare move_parallelogram :: 
    for_unit a: (Parallelogram(a), a*Geom3!) -> Parallelogram(a);

define move_parallelogram(parallelogram, delta) =
    let (v1, v2, color) = parallelogram in
        make_parallelogram(v1 + delta, v2 + delta, color)
    end;
