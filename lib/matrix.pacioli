# Copyright (c) 2013 Paul Griffioen
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy of
# this software and associated documentation files (the "Software"), to deal in
# the Software without restriction, including without limitation the rights to
# use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
# the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
# FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
# COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

module "Matrix";        

# ----------------------------------------------------------------------------
# Indices
# ----------------------------------------------------------------------------

declare _ :: Index();

declare index_less :: for_index P: (P, P) -> Boole();

# ----------------------------------------------------------------------------
# Matrix Shape
# ----------------------------------------------------------------------------

declare make_matrix :: for_index P,Q: for_unit a: (List(Tuple(P, Q, a))) -> a*P! per Q!;

declare magnitude :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> P! per Q!;

declare unit_factor :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a;

declare row_units :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> P!u;

declare column_units :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Q!v;

declare row_domain :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> List(P);

declare column_domain :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> List(Q);

declare row :: for_index P,Q: for_unit a,v: (a*P! per Q!v, P) -> a per Q!v;

declare column :: for_index P,Q: for_unit a,v: (a*P!v per Q!, Q) -> a*P!v;

declare get :: for_index P,Q: for_unit a: (a*P! per Q!, P, Q) -> a;

# ----------------------------------------------------------------------------
# Linear Algebra Operators
# ----------------------------------------------------------------------------

declare sum :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> a*P!u per Q!v;

declare multiply :: for_index P,Q: for_unit a,b,u,w,v,z: (a*P!u per Q!v, b*P!w per Q!z) -> a*b*P!u*P!w per Q!v*Q!z;

declare divide :: for_index P,Q: for_unit a,b,u,v,x,y: (a*P!u per Q!v, b*P!x per Q!y) -> a*P!u/P!x per b/Q!v/Q!y;

declare expt :: for_index P,Q: (P! per Q!, 1) -> P! per Q!;

declare power :: for_index P: for_unit u: (P!u per P!u, 1) -> P!u per P!u;

declare dot :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*Q!v per R!w) -> a*b*P!u per R!w;

declare scale :: for_index P,Q: for_unit a,b,u,v: (a, b*P!u per Q!v) -> a*b*P!u per Q!v;

declare negative :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a*P!u per Q!v;

declare reciprocal :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a^-1*P!u^-1 per Q!v^-1;

declare transpose :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a*Q!v^-1 per P!u^-1;

# ----------------------------------------------------------------------------
# Predicates
# ----------------------------------------------------------------------------

declare less :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> Boole();

declare less_eq :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> Boole();

# ----------------------------------------------------------------------------
# Other Operations
# ----------------------------------------------------------------------------

declare sqrt :: for_index P,Q: for_unit a,u,v: (a^2*P!u^2 per Q!v^2) -> a*P!u per Q!v;

declare log :: for_index P,Q: (P! per Q!, 1) -> P! per Q!;

declare exp :: for_index P,Q: (P! per Q!) -> P! per Q!;

declare ln :: for_index P,Q: (P! per Q!) -> P! per Q!;

declare abs :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> a*P!u per Q!v;

declare max :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> a*P!u per Q!v;

declare min :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> a*P!u per Q!v;

declare gcd :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> P! per Q!;

declare mod :: for_index P,Q: for_unit a,b,u,v,x,y: (a*P!u per Q!v, b*P!x per Q!y) -> a*P!u per Q!v;

declare sin :: for_index P,Q: (radian * P! per Q!) -> P! per Q!;

declare cos :: for_index P,Q: (radian * P! per Q!) -> P! per Q!;

declare tan :: for_index P,Q: (radian * P! per Q!) -> P! per Q!;

declare asin :: for_index P,Q: (P! per Q!) -> radian * P! per Q!;

declare acos :: for_index P,Q: (P! per Q!) -> radian * P! per Q!;

declare atan :: for_index P,Q: (P! per Q!) -> radian * P! per Q!;

declare atan2 :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v, a*P!u per Q!v) -> radian * P! per Q!;

# ----------------------------------------------------------------------------
# Factorizations
# ----------------------------------------------------------------------------

declare plu :: for_index P: for_unit a,u: (a*P!u per P!u) -> Tuple(P!u per P!u, P!u per P!u, a*P!u per P!u);

declare svd :: for_index P,Q: for_unit a,u,v: (a*P!u per Q!v) -> Tuple(P!u per P!u, a*P!u per Q!v, Q!v^-1 per Q!v^-1);

declare solve :: for_index P,Q,R: for_unit a,b,u,v,w: (a*P!u per Q!v, b*P!u per R!w) -> a^-1*b*Q!v per R!w;
