# ------------------------------------------------------------------------------
# Test utilities
# 
# Example use:
#
#   define function_naturals_suite = test_suite("Function 'naturals'", [
#     
#       test("should produce the empty list for 0", () ->
#           naturals(0) = []
#       ),
# 
#       test("should produce the first 5 naturals", () ->
#           naturals(5) = [0, 1, 2, 3, 4]
#       )
#       ]);
# 
#   run_test_suite(function_naturals_suite);
# 
# Expected output:
# 
#   Function 'naturals'
#     should produce the empty list for 0 -> ok
#     should produce the first 5 naturals -> ok
#   All 2 tests succeeded
#
# Replace test and test_suite by variants test_only and test_suite_only to filter
# tests.
#
# ------------------------------------------------------------------------------

declare export test, test_only :: (String, () -> Boole) -> Test;
declare export test_description :: (Test) -> String;
declare export test_is_only :: (Test) -> Boole;
declare export run_test :: (Test) -> Boole;

declare export test_suite, test_suite_only :: (String, List(Test)) -> TestSuite;
declare export suite_description :: (TestSuite) -> String;
declare export suite_tests :: (TestSuite) -> List(Test);
declare export suite_is_only :: (TestSuite) -> Boole;
declare export run_test_suites :: (List(TestSuite)) -> Void;

# ------------------------------------------------------------------------------
# Tests
# ------------------------------------------------------------------------------

deftype Test() = Tuple(String, () -> Boole, Boole);

# ------------------------------------------------------------------------------

doc test
    "Creates a test. 
    
    The first argument is a description of the test case. The second argument is
    a condition that that test must satisfy.

    Example of a test for function <code>naturals</code>:
    <pre>
    test(\"should produce the empty list for 0\", () ->
        naturals(0) = []
    )
    </pre>";

define test(description, body) =
  tuple(description , body, false);

# ------------------------------------------------------------------------------

doc test_only
    "Creates a test, just like function <code>test</code>, but marks it as 'only'.
    
    When at least one test is marked as 'only' then function <code>run_test_suites</code>
    will only run the marked tests and skip all others.";

define test_only(description, body) =
  tuple(description , body, true);

# ------------------------------------------------------------------------------

doc test_description
    "A test's description";

define test_description(test) = 
  let (description, _, _) = test in description end;

# ------------------------------------------------------------------------------

doc test_is_only
    "Is the test marked as 'only'.";

define test_is_only(test) = 
  let (_, _, is_only) = test in is_only end;

# ------------------------------------------------------------------------------

doc run_test
    "Executes the test.";

define run_test(test) = 
  let (_, body, _) = test in body() end;

# ------------------------------------------------------------------------------
# Tests suite
# ------------------------------------------------------------------------------

deftype TestSuite() = Tuple(String, List(Test), Boole);

# ------------------------------------------------------------------------------

doc test_suite
    "Creates a test suite.

    Example:
    <pre>
    define naturals_suite = test_suite(\"Function 'naturals'\", [
        test(\"should produce the empty list for 0\", () ->
            naturals(0) = []
        ),
        test(\"should produce the first 5 naturals\", () ->
            naturals(5) = [0, 1, 2, 3, 4]
        )
    ]);
    </pre>";

define test_suite(description, tests) = 
    tuple(description, tests, false);

# ------------------------------------------------------------------------------

doc test_suite_only
    "Is the test suite marked as 'only'.";

define test_suite_only(description, tests) = 
    tuple(description, tests, true);

# ------------------------------------------------------------------------------

doc suite_description
    "A test suite's description.";

define suite_description(suite) = 
  let (description, _, _) = suite in description end;

# ------------------------------------------------------------------------------

doc suite_tests
    "All tests in a test suite.";

define suite_tests(suite) = 
  let (_, tests, _) = suite in tests end;

# ------------------------------------------------------------------------------

doc suite_is_only
    "Is the test suite marked as 'only'";

define suite_is_only(suite) = 
  let (_, _, is_only) = suite in is_only end;

# ------------------------------------------------------------------------------

doc run_test_suites
    "Runs all tests from a list of test suites. Prints output to the terminal.
    Returns the result as triple (nr_tests, nr_failures, nr_skipped).

    When at least one of the tests is marked as 'only' then it will only run the
    marked tests and skip all others.";

define run_test_suites(suites) =
  begin
    print("\nRuning test suites\n");

    # Determine which suites to run
    suites_with_only := [s | s <- suites, suite_is_only(s)];
    to_test := if suites_with_only = [] then suites else suites_with_only end;
    nr_skipped_suites := list_size(suites) - list_size(to_test);

    # Run the tests. Collect the results as a list of (description, result) pairs
    results := [tuple(suite_description(s), run_test_suite(s)) | s <- to_test];

    # Print a status message
    print(format("\nTests finished, %s suites tested%s\n",
      int2str(list_size(to_test), |1|),
      skipped_message(nr_skipped_suites)));

    # Print a summary of the results per suite. Also calculate totals.
    toprint := results;
    total_nr_tests := 0;
    total_nr_successes := 0;
    while toprint != [] do

      # Get the result for this suite
      (description, result) := head(toprint);
      (nr_tests, nr_errors, nr_skipped) := result;
      nr_successes := nr_tests - nr_errors;

      # Print the result
      print(format(" %s%s -> %s/%s success%s", 
        if nr_successes = nr_tests then " " else "*" end,
        description,
        int2str(nr_successes, |1|),
        int2str(nr_tests, |1|),
        skipped_message(nr_skipped)));

      # Update the totals
      total_nr_tests := total_nr_tests + nr_tests;
      total_nr_successes := total_nr_successes + nr_successes;

      toprint := tail(toprint);
    end

    # Determine total number of skipped
    total_nr_skipped := count[ true | s <- suites, t <- suite_tests(s)] - total_nr_tests;

    # Print the totals
    print(format("\nTotal tests -> %s/%s success%s",
      int2str(total_nr_successes, |1|),
      int2str(total_nr_tests, |1|),
      skipped_message(total_nr_skipped)));
  end;

# ------------------------------------------------------------------------------
# Helpers
# ------------------------------------------------------------------------------

declare run_test_suite :: (TestSuite) -> Tuple(1, 1, 1);
declare skipped_message :: (1) -> String;

doc run_test_suite
    "Runs all tests for a test suite. Prints output to the terminal. Returns the
    result as triple (nr_tests, nr_failures, nr_skipped).

    When at least one of the tests is marked as 'only' then it will only run
    the marked tests and skip all others.";

define run_test_suite(suite) =
  let
    (description, all_tests, _) = suite,
    nr_onlys = count[test_is_only(t) | t <- all_tests],
    tests_with_only = [t | t <- all_tests, test_is_only(t)],
    tests = if tests_with_only = [] then all_tests else tests_with_only end,
    results = [ tuple(test_description(test), run_test(test)) | test <- tests ],
    nr_tests = list_size(tests),
    nr_failures = count[ not(okay) | (_, okay) <- results ],
    nr_skipped = list_size(all_tests) - nr_tests,
    messages = [ message | (description, okay) <- results,
                            result := if okay then "ok" else "FAIL!" end,
                            message := format("  %s -> %s", description, result)],
    summary = if nr_failures = 0 then
                format("All %s tests succeeded", int2str(nr_tests, |1|))
              else
                format("\nTEST FAILURES!!!!!\n\n  %s of %s tests failed",
                  int2str(nr_failures, |1|), 
                  int2str(nr_tests, |1|))
              end
                      
  in
    begin
      print(description);
      todo := messages;
      while todo != [] do
        frst := head(todo);
        todo := tail(todo);
        print(frst);
      end
      print(format("%s%s\n", summary, skipped_message(nr_skipped)));
      return tuple(nr_tests, nr_failures, nr_skipped);
    end
  end;


# Helper to print the number of skipped tests or suites.

define skipped_message(nr_skipped) =
  if nr_skipped = 0 then
    ""
  else
    format(", %s skipped", int2str(nr_skipped, |1|))
  end;
