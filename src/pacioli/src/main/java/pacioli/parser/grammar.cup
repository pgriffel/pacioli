/* Pacioli Grammar */
package pacioli.parser;

// Running
// 
//   java -jar java-cup-11b.jar -interface -parser Parser -locations grammar.cup
// 
// produced
// 
// ------- CUP v0.11b 20160615 (GIT 4ac7450) Parser Generation Summary -------
//   0 errors and 0 warnings
//   79 terminals, 50 non-terminals, and 174 productions declared,
//   producing 377 unique parse states.
//   0 terminals declared but not used.
//   0 non-terminals declared but not used.
//   0 productions never reduced.
//   0 conflicts detected (0 expected).
//   Code written to "Parser.java", and "sym.java".
// ---------------------------------------------------- (CUP v0.11b 20160615 (GIT 4ac7450)) 

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.List;
import java.util.HashMap;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.LinkedList;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
import java_cup.runtime.ComplexSymbolFactory.Location;
import java_cup.runtime.Symbol;
import pacioli.compiler.PacioliException;
import pacioli.ast.*;
import pacioli.ast.definition.*;
import pacioli.ast.definition.UnitVectorDefinition.UnitDecl;
import pacioli.ast.expression.MatrixLiteralNode.ValueDecl;
import pacioli.ast.expression.*;
import pacioli.ast.expression.LetNode.BindingNode;
import pacioli.ast.unit.*;
import pacioli.types.ast.*;
import pacioli.types.ast.TypeIdentifierNode.Kind;

parser code {:

    /* The file being parsed. Only needed for location info. */
    File file;                   

    /* Buffer to get syntax error ino from message and location info
       from CUP's syntax_error to CUP's report_fatal_error
       function. */
    String errorMessage;
    pacioli.compiler.Location errorLocation;

   /* Public interface */
    public Parser(Lexer lex, ComplexSymbolFactory sf, File file) {
        super(lex,sf);
        this.file = file;
    }

    public static ProgramNode parseFile(File file) throws Exception {
        BufferedReader reader = new BufferedReader(new FileReader(file));
        ComplexSymbolFactory csf = new ComplexSymbolFactory();
        Lexer lexer = new Lexer(reader, csf, file, null);
        Parser parser = new Parser(lexer, csf, file);
        return (ProgramNode) parser.parse().value;
    }

   /* CUP overrides to get error handling with location info */
    public void report_error(String message, Object info) {
    }

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();      
        throw new PacioliException(errorLocation, errorMessage);
    }

    public void syntax_error(Symbol cur_token) {
        assert(cur_token instanceof ComplexSymbol);
        List<Integer> ids = expected_token_ids();
        LinkedList<String> list = new LinkedList<String>();
        for (Integer expected : ids){
            list.add(symbl_name_from_id(expected));
        }
        ComplexSymbol token = (ComplexSymbol) cur_token;
        errorLocation = makeLoc(token.getLeft(), token.getRight());
        errorMessage = "Expected one of " + list;
    }

   /* Utility functions for the grammar rules */
    private pacioli.compiler.Location makeLoc(Location from, Location to) {
        pacioli.compiler.Location pacioliFrom = new pacioli.compiler.Location(file, from.getLine(), from.getColumn(), from.getOffset());
        pacioli.compiler.Location pacioliTo = new pacioli.compiler.Location(file, to.getLine(), to.getColumn(), to.getOffset());
        return pacioliFrom.join(pacioliTo);
    }

    private static List<String> idNames(List<IdentifierNode> ids) {
        List<String> names = new ArrayList<String>();
        for (IdentifierNode id: ids) {
            names.add(id.name());
        }
        return names;
    }

    private ValueDefinition functionDefinition(pacioli.compiler.Location loc, IdentifierNode id, List<IdentifierNode> args, ExpressionNode body) {
        ExpressionNode function = new LambdaNode(freshUnderscores(idNames(args)), body, loc);
        return new ValueDefinition(loc, id, function);
    }

    private static List<String> freshUnderscores(List<String> names) {
          List<String> fresh = new ArrayList<String>();
          for (String name : names) {
              if (name.equals("_")) {
                  fresh.add(freshUnderscore());
              } else {
                  fresh.add(name);
              }
          }
          return fresh;
      }

    private static int counter = 0;

    private static String freshUnderscore() {
        return "_" + counter++;
    }
    
    private static String freshName(String prefix) {
        return prefix + counter++;
    }

    private static ExpressionNode binop(String name, ExpressionNode left, ExpressionNode right) {
        pacioli.compiler.Location loc = left.location().join(right.location());
        List<ExpressionNode> args = new ArrayList<ExpressionNode>();
        args.add(left);
        args.add(right);
        return new ApplicationNode(new IdentifierNode(name, loc), args, loc);
    }

    private static ExpressionNode desugarExp(String op, ExpressionNode base, String power,
        pacioli.compiler.Location loc, boolean swapSign) {
      
          int pow = Integer.parseInt(power);
          
        ExpressionNode bas;
        
        if (pow < 0) {
            bas = new ApplicationNode(new IdentifierNode(op.equals("multiply") ? "reciprocal" : "inverse", loc), Arrays.asList(base), loc);
        } else {
            bas = base;
        }
        return desugarExpHelper(op, bas, (pow < 0) ? -pow : pow, loc);
    }

    private static ExpressionNode desugarExpHelper(String op, ExpressionNode base, int power, pacioli.compiler.Location loc) {

        if (power == 0) {
        List<ExpressionNode> args = new ArrayList<ExpressionNode>();
        args.add(base);
        return new ApplicationNode(new IdentifierNode(op.equals("multiply")? "unit" : "left_identity", loc), args, loc);
        } else if (power == 1) {
        return base;
        } else {
        String fresh = freshName(op);

        ExpressionNode exp = new IdentifierNode(fresh, loc);

        for (int i = 1; i < power; i++) {
            List<ExpressionNode> args = new ArrayList<ExpressionNode>();
            args.add(exp);
            args.add(new IdentifierNode(fresh, loc));
            exp = new ApplicationNode(new IdentifierNode(op, loc), args, loc);
        }

        BindingNode binding = new LetBindingNode(loc, fresh, base);
        return new LetNode(Arrays.asList(binding), exp, loc);
        }
    }

    private static ExpressionNode singleop(String name, ExpressionNode exp, pacioli.compiler.Location loc) {
        List<ExpressionNode> args = new ArrayList<ExpressionNode>();
        args.add(exp);
        return new ApplicationNode(new IdentifierNode(name, loc), args, loc);
    }

    private static class GeneratorClause {
        public final IdentifierNode id;
        public final ExpressionNode list;
        public GeneratorClause(IdentifierNode id, ExpressionNode list) {
            this.id = id;
            this.list = list;
        }
    }

    private static class TupleGeneratorClause {
        public final List<IdentifierNode> ids;
        public final ExpressionNode list;
        public TupleGeneratorClause(List<IdentifierNode> ids, ExpressionNode list) {
            this.ids = ids;
            this.list = list;
        }
    }

    private static class AssignmentClause {
        public final IdentifierNode id;
        public final ExpressionNode value;
        public AssignmentClause(IdentifierNode id, ExpressionNode value) {
            this.id = id;
            this.value = value;
        }
    }

    private static class TupleAssignmentClause {
        public final List<IdentifierNode> ids;
        public final ExpressionNode value;
        public TupleAssignmentClause(List<IdentifierNode> ids, ExpressionNode value) {
            this.ids = ids;
            this.value = value;
        }
    }

    private static ExpressionNode desugarComprehension(pacioli.compiler.Location loc, ExpressionNode e, List<Object> ps) throws PacioliException {

        String accuName = freshName("_c_accu");
        String tupName = freshName("_c_tup");

        ExpressionNode addMut = new IdentifierNode("_add_mut", e.location());
        ExpressionNode accu = new IdentifierNode(accuName, e.location());
        ExpressionNode body = new ApplicationNode(addMut, Arrays.asList(accu, e), e.location());
 
        for (int i = ps.size() - 1; 0 <= i; i--) {
            Object part = ps.get(i);
            if (part instanceof GeneratorClause) {
                GeneratorClause clause = (GeneratorClause) part;
                pacioli.compiler.Location loc2 = clause.list.location();
                body = new ApplicationNode(
                                new IdentifierNode("loop_list",loc2),
                                Arrays.asList((ExpressionNode) new IdentifierNode(accuName, loc2),
                                              new LambdaNode(freshUnderscores(Arrays.asList(accuName, clause.id.name())), body, loc2), clause.list),
                                loc2);
            } else if (part instanceof TupleGeneratorClause) {
                TupleGeneratorClause clause = (TupleGeneratorClause) part;
                pacioli.compiler.Location loc2 = clause.list.location();

                List<String> args = new ArrayList<String>();
                for (IdentifierNode var : clause.ids) {
                    args.add(var.name());
                }

                ExpressionNode apply = new IdentifierNode("apply", loc2);
                ExpressionNode restLambda = new LambdaNode(freshUnderscores(args), body, loc2);
                ExpressionNode tup = new IdentifierNode(tupName, loc2);
                ExpressionNode loopList = new IdentifierNode("loop_list", loc2);
                ExpressionNode accuId = new IdentifierNode(accuName, loc2);
                ExpressionNode restApp = new ApplicationNode(apply, Arrays.asList(restLambda, tup), loc2);
                ExpressionNode restAppLambda = new LambdaNode(Arrays.asList(accuName, tupName), restApp, loc2);

                body = new ApplicationNode(loopList, Arrays.asList(accuId, restAppLambda, clause.list), loc2);
            } else if (part instanceof AssignmentClause) {
                AssignmentClause clause = (AssignmentClause) part;

                body = new ApplicationNode(new LambdaNode(freshUnderscores(Arrays.asList(clause.id.name())), body, body.location()), Arrays.asList(clause.value), clause.value.location());
            } else if (part instanceof TupleAssignmentClause) {

                TupleAssignmentClause clause = (TupleAssignmentClause) part;

                List<String> args = new ArrayList<String>();
                for (IdentifierNode var : clause.ids) {
                    args.add(var.name());
                }

                ExpressionNode apply = new IdentifierNode("apply", loc);
                ExpressionNode restLambda = new LambdaNode(freshUnderscores(args), body, loc);

                body = new ApplicationNode(apply, Arrays.asList(restLambda, clause.value), clause.value.location());
            } else if (part instanceof ExpressionNode) {
                ExpressionNode clause = (ExpressionNode) part;
                body = new BranchNode(clause, body, new IdentifierNode(accuName, loc), loc);
            } else {
                throw new PacioliException(loc, "Unexpected clause %s", part);
            }
        }

        ExpressionNode lambda = new LambdaNode(Arrays .asList(accuName), body, loc);
        ExpressionNode emptyListId = new IdentifierNode("empty_list", loc);
        ExpressionNode emptyList = new ApplicationNode(emptyListId, new ArrayList<ExpressionNode>(), loc);

        return new ApplicationNode(lambda, Arrays.asList(emptyList), loc);
    }

    private static ExpressionNode desugarFoldComprehension(pacioli.compiler.Location loc, IdentifierNode op, ExpressionNode e, List<Object> ps) throws PacioliException {
        pacioli.compiler.Location eLoc = e.location(); 
        pacioli.compiler.Location opLoc = op.location();
        ExpressionNode body = desugarComprehension(loc, e, ps);
        if (op.name().equals("sum")) {
            return new ApplicationNode((ExpressionNode) new IdentifierNode("list_sum", eLoc), Arrays.asList(body), opLoc);
        } else if (op.name().equals("count")) {
            return new ApplicationNode((ExpressionNode) new IdentifierNode("list_count", eLoc), Arrays.asList(body), opLoc);
        } else if (op.name().equals("all")) {
            return new ApplicationNode((ExpressionNode) new IdentifierNode("list_all", eLoc), Arrays.asList(body), opLoc);
        } else if (op.name().equals("some")) {
            return new ApplicationNode((ExpressionNode) new IdentifierNode("list_some", eLoc), Arrays.asList(body), opLoc);
        } else if (op.name().equals("gcd")) {
            return new ApplicationNode((ExpressionNode) new IdentifierNode("list_gcd", eLoc), Arrays.asList(body), opLoc);
        } else if (op.name().equals("concat")) {
            return new ApplicationNode((ExpressionNode) new IdentifierNode("list_concat", eLoc), Arrays.asList(body), opLoc);
        } else {
            throw new PacioliException(op.location(), "Comprehension operator '%s' unknown", op.name());
        }
    }

:};


terminal INCLUDE, IMPORT, EXPORT, PUBLIC;
terminal DEFINE, DECLARE, DEFINDEX, DEFTYPE, DEFUNIT, DEFMATRIX, DEFALIAS, DEFCONV, DEFCLASS, DEFINSTANCE, DOC;
terminal IF, ELSE, ELSEIF, BEGIN, END, WHILE, DO, ASSIGN, EXCL, TO, FROM;
terminal IN, LET, PER, THEN, RETURN, FORTYPE, FORUNIT, FORINDEX, FOROP, AT;
terminal COLON, SEMICOLON, DBLCLN, COMMA, LPAR, RPAR, LBRC, RBRC, LBRACK, RBRACK, PIPE;
terminal PLUS, MULT, DIV, MOD, MMULT, HAT, NEG, LEFTDIV, MDIV, MEXPT, MLEFTDIV;
terminal RSCALEDOWN, RSCALE, LSCALEDOWN, LSCALE, TRANS, DIMINV, RECI;
terminal EQL, NEQ, EQUIV, LE, GT, LEQ, GTQ, AND, OR, IMPLIES, FOLLOWSFROM;
terminal String BOOLEAN, NATURAL, DECIMAL, IDENTIFIER, STRING, QUESTIONMARKS, WHERE;


non terminal ProgramNode                     program;
non terminal List<Node>                      includes;
non terminal List<Definition>                commands;
non terminal Definition                      command;
non terminal ExpressionNode                  expr, expr_no_id, if_tail, lettail, letrest, listlit;
non terminal List<ExpressionNode>            exprs, exprlist;
non terminal IdentifierNode                  id, name;
non terminal TypeIdentifierNode              typeid;
non terminal List<IdentifierNode>            ids, names, idlist, idlist_tail, exports;
non terminal List<TypeIdentifierNode>        typeids, typeidlist, typeidlist_tail;
non terminal UnitNode                        dimnum, unit, unit_term;
non terminal String                          unsigned, number, integer;
non terminal StringNode                      path;
non terminal List<UnitDecl>                  unitvec, unitvec_parts;
non terminal List<ValueDecl>                 matrix_parts, matrix;
non terminal TypeNode                        type, type_app, function_type, matrix_type, dim_type;
non terminal SchemaNode                      schema;
non terminal List<QuantNode>                 vardecls;
non terminal List<TypeNode>                  types, typelist;
non terminal TypeIdentifierNode              var;
non terminal List<TypeIdentifierNode>        vars;
non terminal KeyNode                         indexkey;
non terminal ExpressionNode                  comprehension;
non terminal List<Object>                    parts;
non terminal Object                          part;
non terminal List<ExpressionNode>            statements;
non terminal SequenceNode                    sequence;
non terminal ExpressionNode                  statement, stm_if_tail;
non terminal                                 quali;
non terminal List<TypeApplicationNode>       classcondition, conditions;
non terminal TypeApplicationNode             condition;
non terminal List<TypeAssertion>             classmembers, typeassertion;
non terminal List<ValueEquation>             classmemberdefs;
non terminal ValueEquation                   valueeq;

precedence right        TO;
precedence nonassoc     EQUIV, FOLLOWSFROM, IMPLIES;
precedence left         AND, OR;
precedence nonassoc     EQL, LEQ, GTQ, NEQ, LE, GT;
precedence left         PLUS, NEG;
precedence left         MOD;
precedence left         MULT, MMULT, DIV, MDIV, LEFTDIV, MLEFTDIV, LSCALE, RSCALE, LSCALEDOWN, RSCALEDOWN;
precedence left         PER;
precedence left         HAT, MEXPT;
precedence right        TRANS, RECI, DIMINV;
precedence left         LPAR;


//------------------------------------------------------------------------------
// Program
//------------------------------------------------------------------------------

program ::=  
   includes:i commands:c                            {: List<IncludeNode> includes = new ArrayList<IncludeNode>();
                                                       List<ImportNode> imports = new ArrayList<ImportNode>();
                                                       List<ExportNode> exports = new ArrayList<ExportNode>();
                                                       for (Node node : i) {
                                                           if (node instanceof IncludeNode incl) {
                                                               includes.add(incl);
                                                           } else if (node instanceof ImportNode imp) {
                                                               imports.add(imp);
                                                           } else {
                                                               exports.add((ExportNode) node);
                                                           }
                                                       }
                                                       RESULT = new ProgramNode(new pacioli.compiler.Location(file, 0, 0, 0), includes, imports, exports, c); :};

includes ::=  
   includes:is INCLUDE path:p SEMICOLON             {: is.add(new IncludeNode(makeLoc(pxleft, pxright), p)); RESULT = is; :}
 | includes:is IMPORT path:p SEMICOLON              {: is.add(new ImportNode(makeLoc(pxleft, pxright), p)); RESULT = is; :}
 | includes:is EXPORT exports:es SEMICOLON          {: is.add(new ExportNode(makeLoc(esxleft, esxright), es)); RESULT = is; :}
 | /* empty includes */                             {: RESULT = new ArrayList<Node>(); :}
 ;

exports ::=
    exports:es COMMA id:id                          {: RESULT = es; es.add(id); :}
  | exports:es COMMA id:kind id:id                  {: RESULT = es; es.add(id.withKind(kind)); :}
  | id:id                                           {: RESULT = new ArrayList<>(); RESULT.add(id); :}
  | id:kind id:id                                   {: RESULT = new ArrayList<>(); RESULT.add(id.withKind(kind)); :}
  ;

commands ::=  
   commands:cs command:c SEMICOLON                  {: cs.add(c); RESULT = cs; :}
 | /* empty */                                      {: RESULT = new LinkedList<Definition>(); :}
 ;

command ::= 
   DEFINE:d id:id EQL expr:e                        {: RESULT = new ValueDefinition(makeLoc(dxleft, exright), id, e); :}
 | DEFINE:d id:id idlist:ids EQL expr:e             {: RESULT = functionDefinition(makeLoc(dxleft, exright), id, ids, e); :}
 | DECLARE:d ids:ids DBLCLN schema:s                {: RESULT = new MultiDeclaration(makeLoc(dxleft, sxright), ids, s); :}
 | DEFINDEX:d id:id                                 {: List<String> names = new ArrayList<String>();
                                                       RESULT = new IndexSetDefinition(makeLoc(dxleft, idxright), id, names); :}
| DEFINDEX:d id:id EQL LBRC names:ids RBRC:p        {: RESULT = new IndexSetDefinition(makeLoc(dxleft, pxright), id, idNames(ids)); :}
//| DEFINDEX:d id:id EQL LBRC names:ids RBRC:p      {: 
//                                                        pacioli.compiler.Location loc = makeLoc(dxleft, pxright);
//                                                        
//                                                        ExpressionNode list = new ApplicationNode(new IdentifierNode("empty_list", loc), new ArrayList<ExpressionNode>(), loc);
//                                                        for (ExpressionNode item : ids) {
//                                                           List<ExpressionNode> tup = new ArrayList<ExpressionNode>();
//                                                           tup.add(list);
//                                                           tup.add(new StringNode(((IdentifierNode)item).name(), item.location()));
//                                                           list = new ApplicationNode(new IdentifierNode("_add_mut", loc), tup, item.location());
//                                                        }
//                                                        RESULT = new IndexSetDefinition(makeLoc(dxleft, pxright), id, list); :}
 | DEFINDEX:d id:id EQL expr:e                      {: RESULT = new IndexSetDefinition(makeLoc(dxleft, exright), id, e); :}

// Hier geen schema gebruiken!? Als het niet een schema is die in resolving een table vult, maar een handige truc om de type en de vars te krijgen
// dan wegwerken.
 | DEFTYPE:d schema:s EQL type:t                    {: RESULT = new TypeDefinition(makeLoc(dxleft, txright), s.createContext(), s.type, t); :}
 | DEFALIAS:d id:id EQL unit:u                      {: RESULT = new AliasDefinition(makeLoc(dxleft, uxright), id, u); :}
 | DEFUNIT:d typeid:id EXCL typeid:n EQL unitvec:ps {: /* Todo: remove hashmap and use pair list directly in UnitVectorDefinition */
                                                       java.util.Map<String, UnitNode> unitVector = new HashMap<String, UnitNode>();
                                                       for (UnitDecl pair: ps) {
                                                           unitVector.put(pair.key.name(), pair.value);
                                                       }
                                                       RESULT = new UnitVectorDefinition(makeLoc(dxleft, psxright), id, n, ps); :}
 | DEFUNIT:d id:id STRING:s                         {: RESULT = new UnitDefinition(makeLoc(dxleft, sxright), id, s); :}
 | DEFUNIT:d id:id STRING:s EQL dimnum:def          {: RESULT = new UnitDefinition(makeLoc(dxleft, defxright), id, s, def); :}
 | DEFMATRIX:d id:id DBLCLN type:s EQL matrix:m     {: /* Change MatrixLiteralNode to accept a ValueDecl list */
                                                       //List<Pair<List<String>, String>> stringPairs = new ArrayList<Pair<List<String>, String>>();
                                                       //for (ValueDecl decl: m) {
                                                         //  stringPairs.add(new Pair<List<String>, String>(idNames(decl.key), decl.value));
                                                       //}
                                                       ExpressionNode body = new MatrixLiteralNode(makeLoc(mxleft, mxright), s, m);
                                                       //ExpressionNode body = new MatrixLiteralNode(makeLoc(mxleft, mxright), s, stringPairs);
                                                       RESULT = new ValueDefinition(makeLoc(dxleft, mxright), id, body); :}
 | DEFCONV:d id:id DBLCLN type:t                    {: pacioli.compiler.Location loc = makeLoc(dxleft, txright);
                                                       ExpressionNode conv = new ConversionNode(loc, t);
                                                       RESULT = new ValueDefinition(loc, id, conv); :}
 | DOC:d id:id STRING:s                            {: pacioli.compiler.Location loc = makeLoc(dxleft, sxright);
                                                       RESULT = new Documentation(loc, id, new StringNode(s, makeLoc(sxleft, sxright))); :}
 | DOC:d id:kind id:id STRING:s                    {: pacioli.compiler.Location loc = makeLoc(dxleft, sxright);
                                                       RESULT = new Documentation(loc, id.withKind(kind), new StringNode(s, makeLoc(sxleft, sxright))); :}
 | expr:e                                           {: RESULT = new Toplevel(e.location(), e); :}
 | DEFCLASS typeid:id typelist:ids vardecls:v classmembers:e        {: RESULT = new ClassDefinition(id.location(), new TypeApplicationNode(id.location(), id, ids), v, e); :}
 | DEFINSTANCE typeid:id typelist:ids vardecls:v classmemberdefs:e  {: RESULT = new InstanceDefinition(id.location(), new TypeApplicationNode(id.location(), id, ids), v, e); :}
 ;

quali ::=  
   EXPORT {: RESULT = true; :}
 | PUBLIC {: RESULT = true; :}
 | /* empty */
 ;

classmembers ::=
    classmembers:ms COMMA typeassertion:tas          {: ms.addAll(tas); RESULT = ms; :}
    | typeassertion:tas                              {: RESULT = tas; :}
    ;

classmemberdefs ::=
      classmemberdefs:ms COMMA valueeq:eq               {: ms.add(eq); RESULT = ms; :}
    | valueeq:eq                                        {: RESULT = new ArrayList<ValueEquation>(); RESULT.add(eq); :}
    ;

typeassertion ::=
  ids:ids DBLCLN vardecls:c type:t                 {: RESULT = new ArrayList<TypeAssertion>(); 
                                                      for (IdentifierNode id: ids) {
                                                          RESULT.add(new TypeAssertion(makeLoc(idsxleft, txright), id, c, t));
                                                      } :}
  ;

valueeq ::= 
   id:id EQL expr:e                                {: RESULT = new ValueEquation(makeLoc(idxleft, exright), id, e); :}
 | id:id idlist:ids EQL expr:e                     {: ExpressionNode function = new LambdaNode(freshUnderscores(idNames(ids)), e, makeLoc(idxleft, exright));
                                                      RESULT = new ValueEquation(makeLoc(idxleft, exright), id, function); :}
;


//------------------------------------------------------------------------------
// Include path
//------------------------------------------------------------------------------

path ::= 
    STRING:s                                        {: RESULT = new StringNode(s, makeLoc(sxleft, sxright)); :}
 |  IDENTIFIER:s                                    {: RESULT = new StringNode(s, makeLoc(sxleft, sxright)); :}
 |  path:p DIV STRING:s                             {: RESULT = new StringNode(p.valueString() + "/" + s, makeLoc(pxleft, sxright)); :}

 |  path:p DIV IDENTIFIER:s                         {: RESULT = new StringNode(p.valueString() + "/" + s, makeLoc(pxleft, sxright)); :}
 ;

//------------------------------------------------------------------------------
// Matrix and unit vector literals
//------------------------------------------------------------------------------

matrix ::= 
    LBRC RBRC                                       {: RESULT = new LinkedList<ValueDecl>(); :}
  | LBRC matrix_parts:ps RBRC                       {: RESULT = ps; :}
  ;

matrix_parts ::=
    names:ns TO number:n                            {: RESULT = new LinkedList<ValueDecl>(Arrays.asList(new ValueDecl(ns, n))); :}
  | matrix_parts:ps COMMA names:ns TO number:n      {: ps.add(new ValueDecl(ns, n)); RESULT = ps; :}
  ;

unitvec ::= 
   LBRC RBRC                                        {: RESULT = new LinkedList<UnitDecl>(); :}
 | LBRC unitvec_parts:ps RBRC                       {: RESULT = ps; :}
 ;

unitvec_parts ::= 
   name:n COLON unit:u                              {: RESULT = new LinkedList<UnitDecl>(Arrays.asList(new UnitDecl(n, u))); :}
 | unitvec_parts:ps COMMA name:n COLON unit:u       {: ps.add(new UnitDecl(n, u)); RESULT = ps; :}
 ;

//------------------------------------------------------------------------------
// Numbers
//------------------------------------------------------------------------------

number ::= 
   unsigned:u                                       {: RESULT = u; :}
 | NEG unsigned:u                                   {: RESULT = "-" + u; :}
 ;

integer ::= 
   NATURAL:n                                        {: RESULT = n; :}
 | NEG NATURAL:n                                    {: RESULT = "-" + n; :}
 ;

unsigned ::= 
   DECIMAL:d                                        {: RESULT = d; :}
 | NATURAL:n                                        {: RESULT = n; :}
 ;

//------------------------------------------------------------------------------
// Identifiers and names
//------------------------------------------------------------------------------

id ::= IDENTIFIER:id                                {: RESULT = new IdentifierNode(id, makeLoc(idxleft, idxright)); :};

ids ::= 
    id:id                                           {: RESULT = new LinkedList<IdentifierNode>(Arrays.asList(id)); :}
  | ids:ids COMMA id:id                             {: ids.add(id); RESULT = ids; :}
  ;

idlist ::= 
    LPAR RPAR                                       {: RESULT = new LinkedList<IdentifierNode>(); :}
  | LPAR idlist_tail:ids                            {: RESULT = ids; :}
  ;

idlist_tail ::= 
    id:id RPAR                                      {: RESULT = new LinkedList<IdentifierNode>(Arrays.asList(id)); :}
  | id:id COMMA idlist_tail:ids                     {: ids.add(0, id); RESULT = ids; :}
  ;

typeid ::= IDENTIFIER:id                            {: RESULT = new TypeIdentifierNode(makeLoc(idxleft, idxright), id); :};

typeids ::= 
    typeid:id                                           {: RESULT = new LinkedList<TypeIdentifierNode>(); RESULT.add(id); :}
  | typeids:ids COMMA typeid:id                             {: ids.add(id); RESULT = ids; :}
  ;

typeidlist ::= 
    LPAR RPAR                                       {: RESULT = new LinkedList<TypeIdentifierNode>(); :}
  | LPAR typeidlist_tail:ids                            {: RESULT = ids; :}
  ;

typeidlist_tail ::= 
    typeid:id RPAR                                      {: RESULT = new LinkedList<TypeIdentifierNode>(); RESULT.add(id); :}
  | typeid:id COMMA typeidlist_tail:ids                     {: ids.add(0, id); RESULT = ids; :}
  ;
  
name ::= 
   id:id                                            {: RESULT = id; :}
 | STRING:s                                         {: RESULT = new IdentifierNode(s, makeLoc(sxleft, sxright)); :}
 ;

names ::= 
    name:n                                          {: RESULT = new LinkedList<IdentifierNode>(Arrays.asList(n)); :}
  | names:ns COMMA name:n                           {: ns.add(n); RESULT = ns; :}
  ;

//------------------------------------------------------------------------------
// Expressions
//
// Destructing tuples in comprehensions leads to a conflict with parenthesised
// experessions for the case of an identifier in parenthesis, e.g. "(v) <- ..." 
// and "(v) + w". To  avoid this parenthesised expressionss are restricted to 
// LPAR expr_no_id RPAR. The IdListNode construction is for destructuring in 
// comprehensions. See further below. Note that the LPAR id:e RPAR case is still
// supported. It is handled when desugaring IdListNode. See DesugarVisitor.
//------------------------------------------------------------------------------

exprs ::= 
    expr:e                                          {: RESULT = new LinkedList<ExpressionNode>(Arrays.asList(e)); :}
  | exprs:es COMMA expr:e                           {: es.add(e); RESULT = es; :}
  ;

exprlist ::= 
    LPAR RPAR                                       {: RESULT = new LinkedList<ExpressionNode>(); :}
  | LPAR exprs:exprs RPAR                           {: RESULT = exprs; :}
  ;

expr ::= 
   expr_no_id:e                                     {: RESULT = e; :}
 | id:id                                            {: RESULT = id; :}
 ;

expr_no_id ::=
   NEG:n expr:e                                     {: RESULT = singleop("negative", e, makeLoc(nxleft, exright)); :}
 | idlist:ids                                       {: RESULT = new IdListNode(makeLoc(idsxleft, idsxright), ids); :}   
 | LPAR expr_no_id:e RPAR                           {: RESULT = e; :}
 | expr:e1 NEG expr:e2                              {: RESULT = binop("minus", e1, e2); :}
 | expr:e1 HAT integer:e2                              {: RESULT = desugarExp("multiply", e1, e2, makeLoc(e1xleft, e2xright), false); :}
 | expr:e1 PER expr:e2                              {: RESULT = binop("dim_div", e1, e2); :}
 | expr:e1 EQL expr:e2                              {: RESULT = binop("equal", e1, e2); :}
 | expr:e TRANS:t                                   {: RESULT = singleop("transpose", e, makeLoc(exleft, txright)); :}
 | expr:e RECI:r                                    {: RESULT = singleop("reciprocal", e, makeLoc(exleft, rxright)); :}
 | expr:e DIMINV:d                                  {: RESULT = singleop("dim_inv", e, makeLoc(exleft, dxright)); :}
 | expr:e1 MULT:op expr:e2                          {: RESULT = binop("multiply", e1, e2); :}
 | expr:e1 PLUS expr:e2                             {: RESULT = binop("sum", e1, e2); :}
 | expr:e1 MMULT expr:e2                            {: RESULT = binop("mmult", e1, e2); :}
 | expr:e1 MEXPT integer:e2                            {: RESULT = desugarExp("mmult", e1, e2, makeLoc(e1xleft, e2xright), false); :}
 | expr:e1 DIV expr:e2                              {: RESULT = binop("divide", e1, e2); :}
 | expr:e1 MDIV expr:e2                             {: RESULT = binop("right_division", e1, e2); :}
 | expr:e1 LEFTDIV expr:e2                          {: RESULT = binop("left_divide", e1, e2); :}
 | expr:e1 MLEFTDIV expr:e2                         {: RESULT = binop("left_division", e1, e2); :}
 | expr:e1 LSCALE expr:e2                           {: RESULT = binop("scale", e1, e2); :}
 | expr:e1 RSCALE expr:e2                           {: RESULT = binop("rscale", e1, e2); :}
 | expr:e1 LSCALEDOWN expr:e2                       {: RESULT = binop("lscale_down", e1, e2); :}
 | expr:e1 RSCALEDOWN expr:e2                       {: RESULT = binop("scale_down", e1, e2); :}
 | expr:e1 LEQ expr:e2                              {: RESULT = binop("less_eq", e1, e2); :}
 | expr:e1 GTQ expr:e2                              {: RESULT = binop("greater_eq", e1, e2); :}
 | expr:e1 NEQ expr:e2                              {: RESULT = binop("not_equal", e1, e2); :}
 | expr:e1 LE expr:e2                               {: RESULT = binop("less", e1, e2); :}
 | expr:e1 GT expr:e2                               {: RESULT = binop("greater", e1, e2); :}
 | expr:e1 FOLLOWSFROM expr:e2                      {: pacioli.compiler.Location loc = makeLoc(e1xleft, e2xright);
                                                       RESULT = new BranchNode(e2, e1, new ConstNode("true", loc), loc); :}
 | expr:e1 IMPLIES expr:e2                          {: pacioli.compiler.Location loc = makeLoc(e1xleft, e2xright);
                                                       RESULT = new BranchNode(e1, e2, new ConstNode("true", loc), loc); :}
 | expr:e1 EQUIV expr:e2                            {: RESULT = binop("equiv", e1, e2); :}
 | expr:e1 AND expr:e2                              {: pacioli.compiler.Location loc = makeLoc(e1xleft, e2xright);
                                                       RESULT = new BranchNode(e1, e2, new ConstNode("false", loc), loc); :}
 | expr:e1 OR expr:e2                               {: pacioli.compiler.Location loc = makeLoc(e1xleft, e2xright);
                                                       RESULT = new BranchNode(e1, new ConstNode("true", loc), e2, loc); :}
 | expr:fun exprlist:args                             {: RESULT = new ApplicationNode(fun, args, makeLoc(funxleft, argsxright)); :}
 | idlist:ids TO expr:b                             {: RESULT = new LambdaNode(freshUnderscores(idNames(ids)), b, makeLoc(idsxleft, bxright)); :}
 | IF:i expr:c THEN expr:b if_tail:t                {: RESULT = new BranchNode(c, b, t, makeLoc(ixleft, txright)); :}
 | LET lettail:e                                    {: RESULT = e; :}
 | listlit:e                                        {: RESULT = e; :}
 | comprehension:e                                  {: RESULT = e; :}
 | PIPE matrix_type:m PIPE                          {: RESULT = new MatrixTypeNode(makeLoc(mxleft, mxright), m); :}
 | BEGIN:b sequence:s END:e                         {: RESULT = new StatementNode(makeLoc(bxleft, exright), s); :}
 | indexkey:k                                       {: RESULT = k; :}
 | unsigned:u                                       {: RESULT = new ConstNode(u, makeLoc(uxleft, uxright)); :}
 | BOOLEAN:b                                        {: RESULT = new ConstNode(b, makeLoc(bxleft, bxright)); :}
 | STRING:s                                         {: RESULT = new StringNode(s, makeLoc(sxleft, sxright)); :}
 | QUESTIONMARKS:s                                  {: RESULT = new ApplicationNode(new IdentifierNode("_three_question_marks", makeLoc(sxleft, sxright)), new ArrayList<ExpressionNode>() , makeLoc(sxleft, sxright)); :}
 ;

//------------------------------------------------------------------------------
// If
//------------------------------------------------------------------------------

 if_tail ::=
   ELSEIF:i expr:c THEN expr:b  if_tail:t           {: RESULT = new BranchNode(c, b, t, makeLoc(ixleft, txright)); :}
 | ELSE expr:e END                                       {: RESULT = e; :}
 ;

//------------------------------------------------------------------------------
// Index key
//------------------------------------------------------------------------------

indexkey ::=
   name:idx AT name:id                              {: RESULT = new KeyNode(idx.name(), id.name(), makeLoc(idxxleft, idxright)); :}
 | indexkey:k MOD name:idx AT name:id               {: KeyNode node = new KeyNode(idx.name(), id.name(), makeLoc(idxxleft, idxright));
                                                       RESULT = k.merge(node); :}
 ;

//------------------------------------------------------------------------------
// Let
//------------------------------------------------------------------------------

lettail ::=
   id:id EQL expr:e letrest:r                       {: List<String> args = freshUnderscores(Arrays.asList(id.name()));  // remove fresh underscors
                                                       BindingNode binding = new LetBindingNode(makeLoc(idxleft, exright), args.get(0), e);
                                                       RESULT = new LetNode(Arrays.asList(binding), r, makeLoc(idxleft, rxright)); :}
 | idlist:ids EQL expr:e letrest:r                  {: List<String> args = freshUnderscores(idNames(ids));
                                                       pacioli.compiler.Location loc = makeLoc(idsxleft, rxright);
                                                       ExpressionNode fun = new LambdaNode(args, r, r.location());
                                                       RESULT = new ApplicationNode(new IdentifierNode("apply", e.location()), Arrays.asList(fun, e), loc); :}
 | id:id idlist:ids EQL expr:e letrest:r            {: //List<String> rArgs = freshUnderscores(Arrays.asList(id.name()));
                                                       List<String> eArgs = freshUnderscores(idNames(ids)); // remove fresh underscors
                                                       pacioli.compiler.Location loc = makeLoc(idxleft, rxright);
                                                       ExpressionNode eFun = new LambdaNode(eArgs, e, e.location());
                                                       BindingNode binding = new LetBindingNode(makeLoc(idsxleft, exright), id.name(), eFun);
                                                       RESULT = new LetNode(Arrays.asList(binding), r, loc); :}
 ;

letrest ::= 
   IN expr:e END                                    {: RESULT = e; :}
 | COMMA lettail:lt                                 {: RESULT = lt; :}
 ;

//------------------------------------------------------------------------------
// Statements
//------------------------------------------------------------------------------

sequence ::= 
   statements:s                                     {: RESULT = new SequenceNode(makeLoc(sxleft, sxright), s); :}
 ;

statements ::= 
   statement:s                                      {: RESULT = new LinkedList<ExpressionNode>(Arrays.asList(s)); :}
 | statements:ss statement:s                        {: ss.add(s); RESULT = ss; :}
 ;

statement ::= 
    id:id ASSIGN expr:e SEMICOLON:s                 {: RESULT = new AssignmentNode(makeLoc(idxleft, sxright), id, e); :}
  | idlist:ids ASSIGN expr:e SEMICOLON:s            {: RESULT = new TupleAssignmentNode(makeLoc(idsxleft, sxright), ids, e); :}
  | id:id exprlist:es SEMICOLON:s                   {: RESULT = new ApplicationNode(id, es, makeLoc(idxleft, sxright)); :}
  | RETURN:r expr:e SEMICOLON:s                     {: pacioli.compiler.Location loc = makeLoc(rxleft, sxright);
                                                       RESULT = new ReturnNode(loc, e); :}
  | RETURN:r SEMICOLON:s                            {: pacioli.compiler.Location loc = makeLoc(rxleft, sxright);
                                                       RESULT = new ReturnNode(loc, new IdentifierNode("nothing", loc)); :}
  | WHILE:w expr:e DO sequence:s END:n              {: RESULT = new WhileNode(makeLoc(wxleft, nxright), e, s); :}

  | IF:i expr:e THEN sequence:s stm_if_tail:t       {: pacioli.compiler.Location loc = makeLoc(ixleft, txright);
                                                       RESULT = new IfStatementNode(loc, e, s, t); :}
 ;

stm_if_tail ::= 
   ELSEIF:l expr:e THEN sequence:s stm_if_tail:t   {: pacioli.compiler.Location loc = makeLoc(lxleft, txright);
                                                       RESULT = new IfStatementNode(loc, e, s, t); :}
 | ELSE:l sequence:s END:e                         {: RESULT = s; :}
 | END:e                                            {: pacioli.compiler.Location loc = makeLoc(exleft, exright);
                                                       RESULT = new ApplicationNode(new IdentifierNode("_skip", loc), new ArrayList<ExpressionNode>(), loc); :}
 ;

//------------------------------------------------------------------------------
// Lists
//------------------------------------------------------------------------------

listlit ::= 
   LBRACK:l RBRACK:r                                {: pacioli.compiler.Location loc = makeLoc(lxleft, rxright);
                                                       RESULT = new ApplicationNode(new IdentifierNode("empty_list", loc), new ArrayList<ExpressionNode>(), loc); :}
 | LBRACK:l exprs:es RBRACK:r                       {: pacioli.compiler.Location loc = makeLoc(lxleft, rxright);
                                                       ExpressionNode list = new ApplicationNode(new IdentifierNode("empty_list", loc), new ArrayList<ExpressionNode>(), loc);
                                                       for (ExpressionNode item : es) {
                                                           List<ExpressionNode> tup = new ArrayList<ExpressionNode>();
                                                           tup.add(list);
                                                           tup.add(item);
                                                           list = new ApplicationNode(new IdentifierNode("_add_mut", loc), tup, item.location());
                                                       }
                                                       RESULT = list; :}
 ;

comprehension ::= 
   LBRACK:l expr:e PIPE parts:ps RBRACK:r           {: pacioli.compiler.Location loc = makeLoc(lxleft, rxright);
                                                       RESULT = desugarComprehension(loc, e, ps); :}
 | id:id LBRACK expr:e PIPE parts:ps RBRACK:r       {: pacioli.compiler.Location loc = makeLoc(idxleft, rxright);
                                                       RESULT = desugarFoldComprehension(loc, id, e, ps); :}
 ;

parts ::= 
    part:p                                          {: RESULT = new LinkedList<Object>(Arrays.asList(p)); :}
  | parts:ps COMMA part:p                           {: ps.add(p); RESULT = ps; :}
  ;

part ::= 
 | expr:f                                           {: RESULT = f; :}
 | expr:g FROM expr:e                               {:  if (g instanceof IdListNode) {
                                                           RESULT = new TupleGeneratorClause(((IdListNode)g).ids, e);
                                                        } else if (g instanceof IdentifierNode) {
                                                            RESULT = new GeneratorClause((IdentifierNode) g, e);
                                                        } else {
                                                            errorLocation = g.location();
                                                            errorMessage = "Expected a variable or tuple";
                                                            report_fatal_error("Fixme: this string is not used? How to throw an error here?", g);
                                                        }
                                                    :}
 | expr:g ASSIGN expr:e                             {:  if (g instanceof IdListNode) {
                                                           RESULT = new TupleAssignmentClause(((IdListNode)g).ids, e);
                                                        } else if (g instanceof IdentifierNode) {
                                                            RESULT = new AssignmentClause((IdentifierNode) g, e);
                                                        } else {
                                                            errorLocation = g.location();
                                                            errorMessage = "Expected a variable or tuple";
                                                            report_fatal_error("Fixme: this string is not used? How to throw an error here?", g);
                                                        } 
                                                    :}
 ;

//------------------------------------------------------------------------------
// Types and schemas
//------------------------------------------------------------------------------

schema ::=
    vardecls:c type:t                               {: RESULT = new SchemaNode(makeLoc(cxleft, txright), c, t); :};

vardecls ::=
    FORTYPE:f typeids:ids classcondition:cs COLON vardecls:s  {: s.add(new QuantNode(makeLoc(fxleft, sxright), Kind.TYPE, ids, cs));
                                                            RESULT = s; :}
  | FORINDEX:f typeids:ids classcondition:cs COLON vardecls:s {:  s.add(new QuantNode(makeLoc(fxleft, sxright), Kind.INDEX, ids, cs));
                                                            RESULT = s; :}
  | FORUNIT:f vars:vs classcondition:cs COLON vardecls:s  {:  s.add(new QuantNode(makeLoc(fxleft, sxright), Kind.UNIT, vs, cs));
                                                            RESULT = s; :}
  | FOROP:f typeids:vs classcondition:cs COLON vardecls:s    {: s.add(new QuantNode(makeLoc(fxleft, sxright), Kind.OP, vs, cs));
                                                            RESULT = s; :}
  |                                                     {:  RESULT = new ArrayList<QuantNode>(); :}
  ;

classcondition ::=
    WHERE conditions:cs                             {: RESULT = cs; :}
  |                                                 {: RESULT = new ArrayList<TypeApplicationNode>(); :}
  ;
  
conditions ::=
    conditions:cs AND condition:c                   {: RESULT = cs; cs.add(c); :}
  | condition:c                                     {: RESULT = new ArrayList<TypeApplicationNode>(); RESULT.add(c); :}
  ;

condition ::=
    typeid:id typelist:ts                           {: List<TypeNode> nodes= new ArrayList<>();
                                                         //for (TypeIdentifierNode typeid: ts) {
                                                          //  nodes.add(typeid);
                                                        // }
                                                         RESULT = new TypeApplicationNode(makeLoc(idxleft, tsxright), id, ts); :}
  ;

vars ::= 
   var:v                                            {: RESULT = new LinkedList<TypeIdentifierNode>(); RESULT.add(v); :}
 | vars:vs COMMA var:v                              {: vs.add(v); RESULT = vs; :}
 ;

var ::= 
   typeid:id                                        {: RESULT = id; :}
 | typeid:idx EXCL typeid:id                                {: RESULT = new TypeIdentifierNode(makeLoc(idxxleft, idxright), idx.name() + "!" + id.name());  :}
 ;

types ::= 
   type:t                                           {: RESULT = new LinkedList<TypeNode>(Arrays.asList(t)); :}
 | types:ts COMMA type:t                            {: ts.add(t); RESULT = ts; :}
 ;

typelist ::= 
    LPAR RPAR                                       {: RESULT = new LinkedList<TypeNode>(); :}
  | LPAR types:ts RPAR                              {: RESULT = ts; :}
  ;

type ::=
   function_type:fun                                {: RESULT = fun; :}
 | type_app:app                                     {: RESULT = app; :}
 | matrix_type:x                                    {: RESULT = x; :}
 ;


type_app ::=
   typeid:id typelist:ts                            {: RESULT = new TypeApplicationNode(makeLoc(idxleft, tsxright), id, ts); :};

function_type ::=
   typelist:as TO type:b                            {: TypeNode domain = new TypeApplicationNode(makeLoc(asxleft, bxright), 
                                                                            new TypeIdentifierNode(makeLoc(asxleft, asxright), "Tuple"), as);
                                                       RESULT = new FunctionTypeNode(makeLoc(asxleft, bxright), domain, b); :}
 | typeid:a TO type:b                               {: RESULT = new FunctionTypeNode(makeLoc(axleft, bxright), a, b); :}
 ;

matrix_type ::=
   dim_type:x                                       {: RESULT = x; :}
 | dim_type:x PER dim_type:y                        {: RESULT = new TypePerNode(makeLoc(xxleft, yxright), x, y); :}
 ;

dim_type ::=
   dim_type:x MULT dim_type:y                       {: RESULT = new TypeMultiplyNode(makeLoc(xxleft, yxright), x, y); :}
 | dim_type:x DIV dim_type:y                        {: RESULT = new TypeDivideNode(makeLoc(xxleft, yxright), x, y); :}
 | dim_type:x HAT integer:n                         {: RESULT = new TypePowerNode(makeLoc(xxleft, nxright), x, new NumberTypeNode(makeLoc(nxleft, nxright), n)); :}
 | dim_type:x MOD dim_type:y                        {: RESULT = new TypeKroneckerNode(makeLoc(xxleft, yxright), x, y); :}
 | typeid:id                                        {: RESULT = id; :}
 | typeid:p COLON typeid:u                          {: RESULT = new PrefixUnitTypeNode(makeLoc(pxleft, uxright), p, u); :}
 | typeid:i EXCL:e                                  {: RESULT = new BangTypeNode(makeLoc(ixleft, exright), i); :}
 | typeid:i EXCL typeid:u                           {: RESULT = new BangTypeNode(makeLoc(ixleft, uxright), i, u); :}
 | NATURAL:n                                        {: if (n.equals("1")) {
                                                           RESULT = new NumberTypeNode(makeLoc(nxleft, nxright), n);
                                                       } else {
                                                           report_fatal_error("Number unexpected. Only number 1 allowed.", n);
                                                       } :}
 ;

//------------------------------------------------------------------------------
// Units and dimensioned numbers
//------------------------------------------------------------------------------

unit ::= 
   unit_term:t                                      {: RESULT = t; :}
 | unit:x MULT unit:y                               {: RESULT = new UnitOperationNode(makeLoc(xxleft, yxright), "*", x, y); :}
 | unit:x DIV unit:y                                {: RESULT = new UnitOperationNode(makeLoc(xxleft, yxright), "/", x, y); :}
 | unit:x HAT integer:n                             {: RESULT = new UnitPowerNode(makeLoc(xxleft, nxright), x, new NumberUnitNode(n, makeLoc(nxleft, nxright))); :}
 ;

unit_term ::= 
   LPAR unit_term:t RPAR                            {: RESULT = t; :}
 | id:id                                            {: RESULT = new UnitIdentifierNode(id.location(), id.name()); :}
 | id:pre COLON id:id                               {: RESULT = new UnitIdentifierNode(pre.location().join(id.location()), pre.name(), id.name()); :}
 | unsigned:n                                       {: RESULT = new NumberUnitNode(n, makeLoc(nxleft, nxright)); :}
 ;

dimnum ::= unit:u                                   {: RESULT = u; :};
