<h1>Pacioli Manual</h1>

<p>Manual for Pacioli v0.0.0</p>

<hr>

<h2>Contents</h2>

<ul>
<li><a href="#pacioli">Pacioli</a></li>
<li><a href="#datatypes">Values</a></li>
<li><a href="" title="#expressions">Expressions</a></li>
<li><a href="#statements">Statements</a></li>
</ul>

<h2>Pacioli <a id="pacioli"/></h2>

<p>A Paciolo program consists of definitions organized in modules.</p>

<h3>Modules <a id="modules"/></h3>

<p>A module is a collection of definitions and expressions that is
compiled as a unit.</p>

<p>Each module is stored in its own file and starts with keyword <code>module</code>
followed by the module name. A module can include other modules with
an <code>include</code>.</p>

<pre><code>  module "Example";

  include "SI";
  include "Geometry";

  ...
</code></pre>

<p>A module provides namespaces for</p>

<ul>
<li>values and functions</li>
<li>index sets</li>
<li>units and unit vectors</li>
<li>types</li>
</ul>

<p>After the definitions have been processed, the toplevel expressions in
a module are evaluated in the order they appear in the file.</p>

<h3>Toplevel Definitions <a id="toplevel"/></h3>

<h4>Definitions <a id="definitions"/></h4>

<p>A definition starts with keyword <code>define</code> followed by a name, the
equal sign, and an <a href="#expressions">expression</a>. A value is
defined like</p>

<p><code>
define x = <a href="#expressions">expression</a>;
</code></p>

<p>and a function like</p>

<p><code>
define f(x, y, ..., z) = <a href="#expressions">expression</a>;
</code></p>

<h4>Declarations <a id="declarations"/></h4>

<p>A definition can be accompanied by a type declaration. A declaration
starts with keyword <code>declare</code> followed by a name, a pair of colons,
and a type.</p>

<p><code>
declare x :: <a href="#typesystem">type</a>;
</code></p>

<p>Declarations are optional, except for recursive functions. If a type
is declared then it is checked against the definition's infered
type. A declaration may restrict the type, but not generalize or
contradict it.</p>

<h4>Matrix Definitions <a id="matrixdefinition"/></h4>

<p>Syntax is</p>

<p><code>
defmatrix x :: <a href="#matrices">matrix type</a> = {foo, bar -> ..., ...};
</code></p>

<p>A matrix of the declared type with the given numbers is defined.</p>

<h4>Conversion Definitions <a id="conversiondefinition"/></h4>

<p>Syntax is same as declaration</p>

<p><code>
defconv foo :: <a href="#typesystem">matrix type</a>;
</code></p>

<p>A conversion matrix of the declared type is defined as value.</p>

<h4>Projection Definitions <a id="projectiondefinition"/></h4>

<p>Syntax is same as declaration</p>

<p><code>
defproj foo :: <a href="#typesystem">matrix type</a>;
</code></p>

<p>A projection matrix of the declared type is defined as value.</p>

<h4>Index Definitions <a id="indexdefinition"/></h4>

<p>An index set definition starts with keyword <code>defindex</code> followed by a
name, the equal sign, and a set of names.</p>

<p><code>
defindex Foo = {foo, bar, baz};
</code></p>

<p>The defined name is used in <a href="#matrices">matrix</a> types.</p>

<h4>Unit Definitions <a id="unitdefinition"/></h4>

<p>A unit definition starts with keyword <code>defunit</code> and can define a base
unit, a derived unit, or a unit vector.</p>

<p>A base unit definition requires a name and a string to be used in
output.  </p>

<p><code>
defunit metre "m";
</code></p>

<p>A derived unit requires an additonal unit expression. This is an
expression with operators <code>*</code>, <code>/</code> and <code>^</code> on base units or other
derived units.</p>

<p><code>
defunit knot "kn" = 0.51444444*metre/second;
</code></p>

<p>A unit vector is defined for an <a href="#indexdefinition">index set</a> by
specifying a unit for each index key. An exclamation mark seperates
the index set name from the unit vector name.</p>

<p><code>
defunit Foo!unit = {foo: metre, bar: knot, ...};
</code></p>

<p>Unit vectors are used in <a href="#matrices">matrix</a> types.</p>

<h4>Type Definitions <a id="typedefinition"/></h4>

<p>Syntax is</p>

<p><code>
deftype <a href="#typesystem">type</a> = <a href="#typesystem">type</a>;
</code></p>

<p>The defined type must be a parametric type.</p>

<h3>The Type System <a name="typesystem"/></h3>

<p>A type judgement states that an expression is of some type. It is of
the form</p>

<p><code>
<a href="#expressions">expression</a> :: <a href="#schema">schema</a>
</code></p>

<p>Type judgements are used as input in definitions and declarations to
declare a type, and as output by the compiler when the inferred types
are displayed.</p>

<p>The type schema introduces type variables. A type schema is can
introduce ordinary type varibles, index variables, or unit varibles.</p>

<p><code>
for_type a,b,...: <a href="#typesystem">type</a> <br>
for_index P,Q,...: <a href="#typesystem">type</a> <br>
for_unit u,v,...: <a href="#typesystem">type</a>
</code></p>

<p>Index variables are written in uppercase by convention.</p>

<p>A type is one of the two special types for functions and matrices, or
the generic parametric type. The <a href="#functions">function</a> and
<a href="#matrices">matrix</a> type are described in the next section. A
parametric type is of the form</p>

<p><code>
Foo(<a href="#typesystem">type</a>, <a href="#typesystem">type</a>, ...)
</code></p>

<p>Built in types List, Tuple and Boole are parametric types.</p>

<h2>Values <a id="datatypes"/></h2>

<p>Pacioli supports numbers, booleans, lists, tuples, functions and
incides.</p>

<h3>Matrices <a id="matrices"/></h3>

<p>Any numerical value is a matrix. A scalar is a 1x1 matrix. A vector
is a 1xN or a Nx1 matrix.</p>

<p>The type of a <a href="#matrices">matrix</a> is of the form <code>dim per
dim</code>. The row and column types are expressions on units and unit
vectors with operators <code>*</code>, <code>/</code>, <code>^</code> and <code>%</code>. The grammar of the matrix
type's dimensions is</p>

<pre><code>dim ::= dim * dim                          dimensional multiplication
      | dim / dim                          dimensional division
      | dim ^ integer                      dimensional power
      | dim % dim                          dimensional Kronecker
      | term                               matrix type terminal

term ::= identifier ! identifier           dimensioned vector
       | identifier !                      dimensionless vector
       | identifier                        dimensioned number
       | 1                                 dimensionless number
</code></pre>

<p>A terminal in a row or column type expression is the name of a scalar
unit or the name of a dimensioned vector space. A unit scalar is the
dimensionless 1 or a unit like a <code>gram</code> or a <code>metre</code>. A dimensioned
vector space is distinguished from a scalar by an exclamation
mark. The exclamation mark indicates a vector space and is always
preceded by the name of the space's index set.</p>

<p>The matrix type is interpreted at runtime as a unit matrix. For each
dimensioned vector space the representative unit vector is assumed to
be available. Each entry in a matrix type is then given by</p>

<p><code>
(x per y)[i,j] = x[i] / y[j]
</code></p>

<p>The runtime contents of non-terminals is defined inductively, starting
from the contents of the unit vector terminals. Let <code>v</code> and <code>w</code> be
unit vectors</p>

<p><code>
(v * w)[i] = v[i] * w[i] <br>
(v / w)[i] = v[i] / w[i] <br>
(v^n)[i] = v[i]^n <br>
(v % w)[i%j] = v[i] * v[j]
</code></p>

<p>The pair <code>i%j</code> in the last rule is a compound index. Tensors are
matricized with the Kronecker product. This makes multi-dimensional
data transparent for matrices and addresses the issue in the
indices. Multi-dimensional data is indexed with compound indices
instead of multiple row or column indices. See <a href="#indices">Indices</a>.</p>

<h3>Indices <a id="indices"/></h3>

<p>Matrices in Pacioli are indexed by general index sets, not necessarily
integers. Indices are first class language members. They are
accessible via functions <code>row_domain</code> and <code>column_domain</code> or via
literal syntax <em>x</em><code>@</code><em>y</em>, with <em>x</em> an index set and <em>y</em> an index
key. For example <code>Foo@key13</code> or <code>Bar@item42</code>.</p>

<p>A consequence of the matricization of tensors is that a matrix can
have any number of row indices and any number of column indices.  A
row key or column key is a combination of items from possibly multiple
index sets. Compound literal indices are constructed with the <code>%</code>
symbol. For example <code>Foo@key13%Bar@item42</code>. The index type lists all
index sets. In this case:</p>

<pre><code>Index(Foo, Bar)
</code></pre>

<p>Special key <code>_</code> is the only element of the index of zero index sets:</p>

<pre><code>_ :: Index()
</code></pre>

<p>It is used to index the empty row and column domains of scalars and
vectors.</p>

<h3>Booleans <a id="booleans"/></h3>

<p>A Boolean is one of the logical values <code>true</code> or <code>false</code>. </p>

<p>The type of a boolean is <code>Boole()</code>.</p>

<h3>Tuples <a id="tuples"/></h3>

<p>A tuple is a fixed set of values of various types. Functions in
Pacioli expect a tuple of values as argument.</p>

<p>Use function <code>tuple</code> to create a tuple. It returns the tuple of
arguments. Use destructuring in a let or comprehension or use function
<code>apply</code> to retreive the elements of a tuple.</p>

<p>The type of a tuple is </p>

<p><code>
Tuple(<a href="#typesystem">type</a>, <a href="#typesystem">type</a>, ...)
</code></p>

<h3>Lists <a id="lists"/></h3>

<p>A list is a varying set of values of the same type.</p>

<p>The type of a list is </p>

<p><code>
List(<a href="#typesystem">type</a>)
</code></p>

<h3>Functions <a id="functions"/></h3>

<p>Functions are first class values. Functions are globally
<a href="#definitions">defined</a> in a module or anonymous <a href="#lambdas">lambdas</a>.</p>

<p>The type of a function is</p>

<p><code>
(<a href="#typesystem">type</a>, <a href="#typesystem">type</a>, ...) -> <a href="#typesystem">type</a>
</code></p>

<h2>Expressions <a id="expressions"/></h2>

<h3>Constants <a id="constants"/></h3>

<p>Literal constants are numbers, or the Boolean values <code>true</code> or <code>false</code>.</p>

<h3>Variables <a id="variables"/></h3>

<p>A variable is an identifier built from alphanumeric characters and
undercores. A variable can be local or it can refer to a defined value
or function.</p>

<h3>Unit Expressions <a id="unitexpressions"/></h3>

<p>A matrix type surrounded by pipes is a unit expression. For example
<code>|metre|</code> or <code>|Foo!unit per Foo!|</code>.</p>

<h3>Operators <a id="operators"/></h3>

<p>Operators grouped by precedence</p>

<pre><code>-               negative
^T              transpose
^R              reciprocal
^D              dim_inv

.^              power
^               expt

per             dim_div

.               scale
/.              scale_down
*               multiply
/               divide
.*              dot
./              right_division
.\              left_division

+               sum
-               minus

&lt;               less
&lt;=              less_eq
&gt;               greater
&gt;=              greater_eq
=               equal
!=              not_equal

and             and
or              or
&lt;=&gt;             equal
==&gt;             implies
&lt;==             follows_from
</code></pre>

<h3>Function Application <a id="functionapplication"/></h3>

<p>A function application is of the form </p>

<p><code>
foo(<a href="#expressions">expression</a>, <a href="#expressions">expression</a>, ... )
</code></p>

<h3>Lambda <a id="lambdas"/></h3>

<p>An anonymous function is of the form </p>

<p><code>
lambda (x, y, ... ) <a href="#expressions">expression</a> end
</code></p>

<h3>If <a id="if"/></h3>

<p>An if is of the form </p>

<p><code>
if <a href="#expressions">expression</a> then <a href="#expressions">expression</a> else <a href="#expressions">expression</a> end
</code></p>

<h3>Let <a id="let"/></h3>

<p>A let is of the form </p>

<p><code>
let 
    foo = <a href="#expressions">expression</a>,
    bar = <a href="#expressions">expression</a>,
    ...
in
    <a href="#expressions">expression</a> 
end
</code></p>

<p>Each variable can also be a list of variables surrounded by
parenthesis to destructure a tuple.</p>

<h3>Comprehensions <a id="comprehensions"/></h3>

<p>A list comprehension is of the form </p>

<p><code>
[ <a href="#expressions">expression</a> | clause, clause, ... ]
</code></p>

<p>where each clause is</p>

<ul>
<li><p>a generator 
<code>
var &lt;- <a href="#expressions">expression</a>
</code></p></li>
<li><p>a filter 
<code>
<a href="#expressions">expression</a>
</code></p></li>
<li><p>or an assignment
<code>
var := <a href="#expressions">expression</a>
</code></p></li>
</ul>

<p>Each var can also be a list of variables surrounded by parenthesis to
destructure a tuple.</p>

<h2>Statements <a id="statements"/></h2>

<p>A statement is of the form </p>

<p><code><pre>
begin
  <a href="#statements">statement</a>;
  <a href="#statements">statement</a>;
  ...
end
</code></pre></p>

<p>A <a href="#return">return</a> leaves the block prematurely.</p>

<h3>Assignment <a id="assignment"/></h3>

<p>An assignment is of the form </p>

<p><code>
var := <a href="#expressions">expression</a>
</code></p>

<p>The value stored by variable <code>var</code> is changed to the value of the
expression. The variable can also be a list of variables surrounded by
parenthesis to destructure a tuple.</p>

<h3>Return <a id="return"/></h3>

<p>A return statement is of the form</p>

<p><code>
return <a href="#expressions">expression</a>
</code></p>

<p>Execution of the surrounding <code>begin</code> <code>end</code> block is halted and the
returned value becomes the value of the block. The expression is
optional.</p>

<h3>While <a id="while"/></h3>

<p>A while statement is of the form</p>

<p><code><pre>
while <a href="#expressions">expression</a> do
  <a href="#statements">statement</a>
end
</code></pre></p>

<p>The body of the while loop is executed as long the expression is true.</p>

<h3>If <a id="ifstatement"/></h3>

<p>An if statement is of the form</p>

<p><code><pre>
if <a href="#expressions">expression</a> then
  <a href="#statements">statement</a>
elseif <a href="#expressions">expression</a> then
  <a href="#statements">statement</a>
...
else
  <a href="#statements">statement</a>
end
</code></pre></p>

<p>The <code>else</code> and <code>elseif</code> are optional. </p>

<hr>

<p>2013 Paul Griffioen</p>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>

<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-5527808-1");
pageTracker._trackPageview();
</script>
